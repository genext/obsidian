---
title: "디지털 바우처 프로젝트"
created: 2024-06-20 08:55:58
updated: 2025-09-25 16:46:29
---

## 김기수 대표 Anydesk 접속 정보

- 연결 세션 번호 : 1 714 802 166
- 세션연결 PASS :  Ccmedia@2024  (대소문자 구분)
- GabiaDaas 계정:kskim
- GabiaDaas PASS:[Ccmedia@2024](mailto:Ccmedia@2024)

## 스마트계약 배포 완료 후 바우처 제조 및 이체?

- 스마트 계약은 기능과 파라미터를 정의한 것뿐
- 바우처 기능을 부여하는 것은 따로 있으며 이걸 바우처 제조 및 이체라고 하는 것 같다.

## 업무 분석 단계 의문점
- 어떤 바우처로 테스트 진행할 것인지 정해야 한다. 이건 중요하지 않다.
[[CBDC 기반 디지털 바우처 관리 플랫폼]]
## 구현 단계 의문점(요소 기술)

### 블록체인 스마트계약 호출

- 블록체인의 스마트계약을 호출할 때는 JSON-RPC를 사용한다고 함. 누가 호출? --> 블록체인 sdk나 core에서...

### CBDC 플랫폼 연계

- 기관용 CBDC, 예금 토큰 등 디지털 통화와 디지털 바우처 연계 --> PBM

### 바우처 거래 흐름

- 바우처 거래 시 전체적인 흐름, 연동 부분, 연동 부분에서 호출 주체와 결과값 명확화 필요. 전자지갑, 바우처, 오라클계약, 스마트계약 등
- 바우처 사용 시, 전자지갑에서 오라클 계약의 API 직접 호출 -> 스마트계약 호출 -> 호출 결과를 오라클계약 관리 시스템 내  거래기록 DB에 저장? --> 이것도 블록체인 sdk나 코어에서..
- 거래기록 DB는 각 시스템에서 바로 조회 가능? 아니면 API로 제공?

## 디지털 바우처 사용처에 지급 서비스는 어떻게?

- 이용자 전자지갑에서 디지털 바우처 표준 API 호출하여 결제 승인 요청 -> 참가기관 시스템에서 관리기관의 oracle계약 API 호출하면서 이용자의 조건  금액 전달 -> 스마트계약 실행 -> 거래 결과가 블록체인과 관리기관 미러링 DB 저장 -> 중앙기관에서 거래 결과 kafka에 전송 -> 참가기관 시스템에서 수신 -> 사용처측 참기기관 시스템에서 거래 결과에 따라 예금 토큰 발행하여 사용처 전자지갑에 **실시간** 입금?
- 이용자 전자지갑이 블록체인 노드로서 거래 직접 유발? 아니면 유통 시스템이 대리 수행? --> 중요하지 않다.

## 이용자 전자지갑

이용자 전자지갑은 EOA 타입. 이로 미루어 사용처 지갑도 EOA 타입이어야 한다는 것을 알 수 있고 지갑과 지갑 사이에서 바로 송금 가능하다.

## 바우처 부정 수급은 디지털 바우처 관리 시스템에서 막을 수 있나?

- 장애인 여부는 각 참가기관의 개인 정보에 없을 텐데?

## backend/out 무슨 디렉토리?

- mapper를 정의하는 곳인 듯. 여기에 ~Mapper.xml 파일들이 많이 있음.
- application과 domain 각각에 bank와 ewa가 공통적으로 들어있음.

## recoil 파악

## java persistent framework

MyBatis와 이보다 최신 기술인 JBatis?? 조사

## myBatis 구현 방법

- chatGPT에 문의하고 실제로 구현해보기
- 이건 실제 cbdc 백엔드 소스를 보면서 해소함.

## 디지털 바우처를 어떻게 타행 이용자가 소유한 전자지갑에 전송?

- 전자지갑과 바우처 사이 표준 인터페이스와 API --> web view 제공

## bok의 WalletManageServiceImpl.java에서 블록체인 속 내용과 지갑 생성 이유 확인

## td와 dc1, dc2 차이는?

## 이용자 앱 시스템 구성

이용자 앱 시스템 구성은? 사용처 앱처럼 은행 수퍼 앱과 웹뷰로 연결된 상태? 이용자 앱은  CI 연동 보안성 문제를 어떻게 처리했는지?

## 하 박사 요청

지갑주소와 은행코드, TD 코드 관리체계 파악해서 알려주기.

- 씨씨미디어자료/KISA 전달 산출물_2024-06-03에 있는 CBDC-TD 연계관련 인터페이스정의서_V0.5.xlsx 문서와 바우처 컨트랙트 키관리방안 분석서를 메일로 전달해줌.

## CIT 부산동백전 캐시백 바우처 사용 흐름 문제

유승헌 부장이 작성한 결제 시나리오 중 CIT 부산동백전 캐시백 바우처 사용 흐름에 문제가 있음. 이용자 은행에서 어떻게 의뢰기관 은행에게 거래 승인 요청을 보낼 수 있나? 못 할 텐데?

## 사용처 관리

사용처 관리에서 사용처 테이블을 어디에 놓을지가 문제. 가맹주 데이터는 은행에서 관리할 것이 거의 확실하지만 사용처 테이블은? 이건 사용처 앱에서 생성할 것 같은데 문제는 전자지갑 -> 각 은행에서 관리하는 것으로 가는 것이 거의 확실

## 8월 2일까지 개발환경 설정 완료

## source

- [CfHfQXq-cM.zip](Roam/genext-2025-10-05-02-18-30/Attachments/imgs/app/genext/CfHfQXq-cM.zip)
- [4sNil3tKVL.zip](Roam/genext-2025-10-05-02-18-30/Attachments/imgs/app/genext/4sNil3tKVL.zip)
- [pYJiLS1w_3.zip](Roam/genext-2025-10-05-02-18-30/Attachments/imgs/app/genext/pYJiLS1w_3.zip)
- [8uo_bhPyiL.zip](Roam/genext-2025-10-05-02-18-30/Attachments/imgs/app/genext/8uo_bhPyiL.zip)

## 000.000.000.000 DB 서버

root password: xxxx

## DB 사용자 id/password 만들 것

id/passwd: xxxxx/xxxx.

## 디지털 바우처 DB 생성 및 테이블 생성

## 디지털 바우처 서버 환경

### 1) kafka

```
000.000.000.000:9091
/app/kafka_2.12-3.7.1/bin# ./kafka-topics.sh  --bootstrap-server 000.000.000.000:9091 --list
```

### 2) BESU

아래 IP 변경 - 000.000.000.000

- JSON-RPC HTTP service endpoint                 : http://localhost:8545
- JSON-RPC WebSocket. service endpoint            : ws://localhost:8546
- Web block explorer address                     : http://localhost:25000/explorer/nodes

### 3) REDIS

TCP Port - 6379

### 4) MYSQL

TCP Port - 3306

## 메뉴구조도 엑셀 파일

메뉴구조도_url_삽입 NAS 참고자료 디렉토리)에 url 넣기

## 번갯불에 콩 볶아 먹듯이 서두르다 보니 초반에 간과했던 기술적 부담이 나중에 되돌아 온다.

## grid 관련 라이브러리 분석

## BaseEntity에서 JOB_TYPE 처리

BaseEntity에서 JOB_TYPE 처리 에러난 것이나 swagger에서 get_JOB_TYPE으로 표시된 이유 찾기.

## countRecruitInfo sql 문 분석

countRecruitInfo sql 문의 table join이 과연 필요한 것인지 확인. 그리고 countApplcnt에서는 DISTINCT 안 쓴 이유 분석

Great observation! Whether or not to use DISTINCT in the COUNT query depends on the specific nature of your data and your query logic.

### When to Use DISTINCT:

- **Duplicate Rows**: If your JOIN statements or the data itself can lead to duplicate rows being included in the result set, then you should use DISTINCT to ensure that the count reflects the unique records.
- **Grouped Data**: If your original SELECT query involves GROUP BY or if multiple rows could represent the same logical entity, you might need DISTINCT to count the unique occurrences.

### When Not to Use DISTINCT:

If there are no potential duplicates caused by the JOIN operations and each row in the result set represents a unique record, then you don't need DISTINCT.

### Evaluating the Current Query:

**selectApplcnt Query**: Based on the query structure provided, where you're joining multiple tables but there's no explicit GROUP BY clause, the potential for duplicates depends on the data in the joined tables.

- **Example Scenario**: If TB_VOUCH_CSTMR_RCRIT (aliased as CR) is the main table and you're simply joining related data without any possibility of duplicating rows from this table, DISTINCT may not be necessary.
- However, if the JOIN conditions could result in multiple rows for the same CR.CSTMR_NO (due to multiple related records in other tables), then DISTINCT would be required.

### Adding DISTINCT (if needed):

If there is any potential for duplicate rows, you can modify the COUNT query to include DISTINCT:

```sql
<select id="countApplcnt" resultType="int">
    <![CDATA[
    SELECT COUNT(DISTINCT CR.CSTMR_NO)
    FROM TB_VOUCH_CSTMR_RCRIT CR
    LEFT JOIN TB_VOUCH_MASTR VM ON CR.VOUCH_ID = VM.VOUCH_ID
    LEFT JOIN TB_CSTMR_MASTR CM ON CM.CSTMR_NO = CR.CSTMR_NO
    LEFT JOIN TB_SYS_CODE_GROUP SCG ON SCG.CD_GROUP = 'VOUCH_APPLCNT_PROC_YN'
    LEFT JOIN TB_SYS_CODE_VALUE SCV ON SCV.CD_GROUP_ID = SCG.CD_GROUP_ID AND SCV.CD_VALUE = CR.REQST_YN
    LEFT JOIN TB_SYS_CODE_GROUP SCG_BANK ON SCG_BANK.CD_GROUP = 'BANK_CD'
    LEFT JOIN TB_SYS_CODE_VALUE SCV_BANK ON SCV_BANK.CD_GROUP_ID = SCG_BANK.CD_GROUP_ID
                                AND SCV_BANK.CD_VALUE = CR.BANK_CD
    WHERE 1 = 1
    AND CR.VOUCH_ID = #{search.vouchId}
    ]]>
</select>
```

### Key Changes:

**COUNT(DISTINCT CR.CSTMR_NO)**: This ensures that the count reflects the number of unique CSTMR_NO values, preventing over-counting if any duplicates exist due to the JOIN operations.

### Conclusion:

- **No DISTINCT Needed**: If you are confident that your query doesn't produce duplicate rows, you can safely use COUNT(1).
- **Use DISTINCT**: If there's any chance that JOIN operations could produce duplicate rows, it's safer to use COUNT(DISTINCT CR.CSTMR_NO).

Review your data structure and the nature of the relationships to decide if DISTINCT is necessary in your specific case.

## return type으로 쓰이는 타입 분석

### BaseMap

```java
package kr.or.cbdc.infrastructure.framework.core.support.collection;

import java.util.Date;
import java.util.LinkedHashMap;

public class BaseMap extends LinkedHashMap<String, Object> {

    private static final long serialVersionUID = -4733454764883396871L;

    public void longToDate(String... keys) {
        for (String key : keys) {
            if (this.get(key) != null) {
                this.put(key, new Date(Long.parseLong(this.get(key) + "")));
            }
        }
    }

}
```

### BaseMapList

```java
package kr.or.cbdc.infrastructure.framework.core.support.collection;

import java.util.ArrayList;

public class BaseMapList extends ArrayList<BaseMap> {

    private static final long serialVersionUID = 6609424130927825087L;

    public Object get(int i, String key) {
        return this.get(i).get(key);
    }

}
```

## React 소스

### 금결원

#### 내가 작업한 것

2024-10-15: frontend(React) 작업

#### 내가 빠진 후 작업한 것

[6JyC5imEeQ.zip](Roam/genext-2025-10-05-02-18-30/Attachments/imgs/app/genext/6JyC5imEeQ.zip)

### 참가기관 시스템

2024-10-18: 디지털 바우처 참가기관 시스템 front(React+grid) 작업

### 디지털 바우처 React 프로젝트 소스 분석

2024-08-17 11:53: 디지털 바우처 React 프로젝트 소스 분석
