---
title: "July 27th, 2025"
created: 2025-07-27 08:22:08
updated: 2025-07-28 08:30:59
---
  * 08:22 오늘 부모표 중 자식표가 있었던 자리에 있는 자식표 내용 대신, 자식표 번호를 알려주면서 참조하라는 글로 치환하는 것을 목표로...그러기 위해서 일단 현재 프로그램을 제대로 알고 있어야 정확하게 요청할 수 있다는 생각에 프로그램 분석 시작
  * 08:26 detect_parent_child_tables(tab_rects) 숙지
    * tab_rects: Dict
      * tab_rects.items: List. 이 배열은 부모표와 자식표 구분없이 다 포함.
        * parms.tabs.tables 배열을 돌면서 얻은 Rect값
    * 핵심 논리
      * tab_rects를 이중 for문 돌면서 비교. 
      * 첨자가 다르고 tab_rects.items() 결과가 같으면 자식표 배열에 추가. 결국 내용은 같은데 첨자만 다른 것을 자식표 배열에 넣는다는 건데...
      * 같은 내용이 연달아 있으면 첫 번째가 부모표고 그 다음이 자식표라는 가정에서 출발. 괜찮은 건가?
  * 09:04 get_page_output에 Parameters라는 클래스로 parms라는 객체를 만들어서 거기에 페이지 모든 정보를 넣은다. 분석해서 자료로 남기기 시작
    * @dataclass
      * 이 데코레이터가 꾸미는 클래스에게 저장을 위한 특수 메소드를 자동 생성해 줌.
      * ```python
- 예제
@dataclass(frozen=True)  # Makes instances immutable
class Point:
    x: float
    y: float

@dataclass(order=True)  # Adds comparison methods (<, >, etc.)
class Score:
    value: int```
    * Parameters 클래스
      * 처음에는 속성없이 시작하지만 get_page_output에서 속성 추가
      * 내 코드
        * ```python

@dataclass
class Parameters:
  parent_child_map:dict = None
  child_parent_map: dict = None```
    * 자료 구조
      * 전체 구조
        * ```python
Parameters:
{
    # Page information
    "page": <pymupdf.Page object>,
    "filename": "input.pdf",
    
    # Output strings
    "md_string": "# Sample Header\nThis is sample text...",
    
    # Page-level data collections
    "images": [
        {
            "number": 0,
            "bbox": (100.0, 200.0, 300.0, 400.0),  # Rect coordinates
            "width": 200,
            "height": 200,
            "colorspace": 3,
            "xres": 96,
            "yres": 96,
            "bpc": 8,
            "transform": (200.0, 0.0, 0.0, -200.0, 100.0, 400.0),
            "size": 40000
        }
    ],
    
    "tables": [
        {
            "bbox": (50.0, 100.0, 550.0, 300.0),
            "rows": 5,
            "columns": 3
        }
    ],
    
    "graphics": [],  # Would contain vector graphics info
    
    "words": [
        (72.0, 100.0, 120.0, 112.0, "Hello", 0, 0, 0),  # x0, y0, x1, y1, text, block_no, line_no, word_no
        (125.0, 100.0, 170.0, 112.0, "World", 0, 0, 1)
    ],
    
    # Rectangle collections
    "line_rects": [
        <pymupdf.Rect(72.0, 100.0, 170.0, 112.0)>,
        <pymupdf.Rect(72.0, 120.0, 250.0, 132.0)>
    ],
    
    "img_rects": [
        <pymupdf.Rect(100.0, 200.0, 300.0, 400.0)>,
        <pymupdf.Rect(350.0, 200.0, 550.0, 400.0)>
    ],
    
    "annot_rects": [
        <pymupdf.Rect(400.0, 100.0, 500.0, 150.0)>
    ],
    
    "vg_clusters0": [  # Vector graphics clusters
        <pymupdf.Rect(50.0, 450.0, 150.0, 550.0)>
    ],
    
    "vg_clusters": {
        0: <pymupdf.Rect(50.0, 450.0, 150.0, 550.0)>
    },
    
    # Table-related
    "tabs": <pymupdf.table.TableFinder object with tables list>,
    "tab_rects": {
        0: <pymupdf.Rect(50.0, 100.0, 550.0, 300.0)>,
        1: <pymupdf.Rect(50.0, 350.0, 550.0, 500.0)>
    },
    "tab_rects0": [  # List version of tab_rects values
        <pymupdf.Rect(50.0, 100.0, 550.0, 300.0)>,
        <pymupdf.Rect(50.0, 350.0, 550.0, 500.0)>
    ],
    
    # Parent-child table relationships
    "parent_child_map": {
        0: [2, 3],  # Table 0 contains tables 2 and 3
        1: [4]      # Table 1 contains table 4
    },
    "child_parent_map": {
        2: 0,  # Table 2's parent is table 0
        3: 0,  # Table 3's parent is table 0
        4: 1   # Table 4's parent is table 1
    },
    
    # Tracking written elements
    "written_tables": [0, 1],  # Indices of tables already written
    "written_images": [0, 2, 3],  # Indices of images already written
    
    # Page properties
    "clip": <pymupdf.Rect(0.0, 0.0, 612.0, 792.0)>,  # Page clip area
    "bg_color": (1.0, 1.0, 1.0),  # RGB values (white background)
    "accept_invisible": False,  # Whether to accept invisible text
    
    # Text and link data
    "textpage": <pymupdf.TextPage object>,
    "links": [
        {
            "kind": 2,  # LINK_URI
            "from": <pymupdf.Rect(100.0, 200.0, 200.0, 220.0)>,
            "uri": "https://example.com",
            "page": -1
        }
    ],
    
    # Drawing paths (for vector graphics)
    "actual_paths": [
        {
            "rect": <pymupdf.Rect(50.0, 450.0, 150.0, 550.0)>,
            "type": "l",  # line
            "items": [...],  # path commands
            "fill": None,
            "stroke": (0.0, 0.0, 0.0),  # black stroke
            "width": 1.0,
            "closePath": False
        }
    ]
}```
      * tabs를 상세화하고 나머지 간단하게
        * ```python
Parameters:
{
    # Page information
    "page": <pymupdf.Page object>,
    "filename": "input.pdf",
    "md_string": "# Sample Header\nThis is sample text...",
    
    # Simplified collections
    "images": [{"bbox": (100.0, 200.0, 300.0, 400.0), ...}],  # list of image info dicts
    "tables": [{"bbox": (50.0, 100.0, 550.0, 300.0), "rows": 5, "columns": 3}],
    "graphics": [],  # vector graphics info
    "words": [(72.0, 100.0, 120.0, 112.0, "Hello", 0, 0, 0)],  # word tuples
    "links": [{"uri": "https://example.com", "from": <Rect>}],  # simplified
    
    # Rectangle collections (simplified)
    "line_rects": [<Rect>, <Rect>, ...],
    "img_rects": [<Rect>, <Rect>, ...],
    "annot_rects": [<Rect>, ...],
    "vg_clusters0": [<Rect>, ...],
    "vg_clusters": {0: <Rect>, 1: <Rect>},
    
    # DETAILED TABLE STRUCTURE
    "tabs": <TableFinder object> {
        "tables": [
            <Table object> {
                "page": <pymupdf.Page>,
                "cells": [  # List of cell bboxes (x0, y0, x1, y1)
                    (50.0, 100.0, 150.0, 130.0),   # Cell[0,0]
                    (150.0, 100.0, 250.0, 130.0),  # Cell[0,1]
                    (250.0, 100.0, 350.0, 130.0),  # Cell[0,2]
                    (50.0, 130.0, 150.0, 160.0),   # Cell[1,0]
                    (150.0, 130.0, 250.0, 160.0),  # Cell[1,1]
                    (250.0, 130.0, 350.0, 160.0),  # Cell[1,2]
                ],
                "bbox": (50.0, 100.0, 350.0, 160.0),  # Table's overall bbox
                "rows": [
                    <TableRow> {
                        "cells": [
                            (50.0, 100.0, 150.0, 130.0),   # or None for empty
                            (150.0, 100.0, 250.0, 130.0),
                            (250.0, 100.0, 350.0, 130.0)
                        ],
                        "bbox": (50.0, 100.0, 350.0, 130.0)
                    },
                    <TableRow> {
                        "cells": [...],
                        "bbox": (50.0, 130.0, 350.0, 160.0)
                    }
                ],
                "row_count": 2,
                "col_count": 3,
                "header": <TableHeader> {
                    "bbox": (50.0, 80.0, 350.0, 100.0),  # Header bbox
                    "cells": [  # Header cell bboxes
                        (50.0, 80.0, 150.0, 100.0),
                        (150.0, 80.0, 250.0, 100.0),
                        (250.0, 80.0, 350.0, 100.0)
                    ],
                    "names": ["Column A", "Column B", "Column C"],  # Header text
                    "external": True  # True if header is above table cells
                }
            },
            <Table object> { ... }  # Second table
        ],
        "edges": [...],  # Detected edges used for table detection
        "intersections": {...},  # Edge intersection points
        "cells": [...]  # All detected cells before grouping into tables
    },
    
    "tab_rects": {  # Dictionary mapping table index to its rectangle
        0: <Rect(50.0, 80.0, 350.0, 160.0)>,   # Includes header
        1: <Rect(50.0, 200.0, 350.0, 300.0)>,
        2: <Rect(100.0, 120.0, 200.0, 140.0)>  # Nested table
    },
    
    "tab_rects0": [  # List version of tab_rects values
        <Rect(50.0, 80.0, 350.0, 160.0)>,
        <Rect(50.0, 200.0, 350.0, 300.0)>,
        <Rect(100.0,```
  * 09:47 params 중 테이블 관련 데이터 분석하기 위해 로그 찍도록 시작
  * 12:40 자식표를 가리키는 문구를 부모표의 자식표가 있는 칸에 추가 시작
    * claude에 로그 파일을 첨부했지만 너무 커서 로그 간소화하고 다시 테스트
  * 13:11 역시 한 번에 되지 않는다. 수정하고 다시 시작
    * 하다 보니...markdown 결과에서 제목 위치나 표 위치가 정확하지 않은 것이 문제가 될 수도 있다는 것을 깨닫다. 별 수없이 제목 위치가 정확하게 나오지 않는 이유부터 잡아야겠다.
  * 13:47 내 힘으로 하는 수밖에 없겠다. 지금부터 잠 잘 때까지 남은 시간은 7시간인데 똑똑하게 일해야 한다.
  * 13:51 일단 page 20에 Refer to 문장이 하나씩 밀리는 이유 분석 시작.
    * 일단 bbox를 보면 확실하게 표 크기와 위치 파악 가능. p16 표 로그를 보니 확실.
  * 14:59 이제 로그 정밀 분석 시작
    * get_page_output() ^F3gpqGCt1
      * parms에 page 정보 저장
      * 표 정보 저장 tab_rects. 뒤에 나오는 text_rects와 혼란 우려
      * detect_parent_child_tables()로 부모, 자식 표 저장
      * column_boxes로 text_rects 저장
      * 그런데 output_tables가 text_rects를 가지고 표 내용을 저장해??????
    * 도대체 어디 글을 가지고 표 내용을 저장하는지 혼란스러워서 다시 output_tables() 근처에서 로그를 자세하게 찍도록 수정 후 테스트.
  * 15:36 도대체 진짜 어떤 함수가 표 내용을 쓰는지 헷갈린다. 일단 원본과 차이점을 적는다.
    * write_text() 변경
      * 원본: parms.tabs[i].to_markdown() 호출
      * 내 것: get_table_tag로부모표, 자식표 관계 markdown에 저장 -> 원본 코드 -> replace_child_table_content_in_markdown()으로 바꿔치기 시도
    * output_tables() 변경: 이건 if/else에 각각 있다
      * 원본: parms.tabs[i].to_markdown() 호출
      * 내 것: get_table_tag -> 원본 코드 -> replace_child_table_content_in_markdown()
  * 15:48 다시 로그 추가해서 분석...피곤하다. 프로그램이 지저분해...로그도 분석하기 복잡해서 정리 중...시간 다 간다...
    * p16은 이상한 것이 "This Table contains..."가 else문에서 추가되는데 실제로 추가되지 않는다. 왜? -> 내가 잘못 본 거다. 이것 때문에 이후 7시까지 시간을 허비했다. 목표를 잃고 중간에 헤맸다.
    * else 문에서 replace가 실행되는데 왜 if문에 있는 것은 실행로그가 없지?
    * 일단 로그가 이상한 점.
      * get_table_tag가 제일 먼저 실행되고 table_md에 추가되어야 한다.
      * parent 테이블일 때 그 안에 있는 markdown을 수정해야 하지 않을까?
      * 정확하게 누가 시작과 종료를 정하지?
  * 16:51 일하다 보니 25분이 너무 짧은 것 같아서 50분으로 늘림.
  * 16:52 표에 있는 글을 쓰기 시작하는 시점과 완전히 끝나는 시점을 먼저 파악. 그리고 나서 시작점에 get_table_tag 호출하고 끝나기 직전에 replace를 호출하는 방향으로..
    * 시작점: to_markdown의 for-loop for page에서 
      * get_page_output() 내부 흐름은 [[July 27th, 2025#^F3gpqGCt1|get_page_output()]] 참조
        * output_tables()에서 get_table_tag() 호출하지만 실행 조건 불명확
  * 17:19 아이고 이제야 p16에서 "This table contains"가 없었는지 발견했다. 배열 지표값이 일관되지 않은데? p6은 첫 번째 테이블인데도 1로 저장되었고 정상적으로 부모표라고 표시한 것은 첫 번째 테이블이 0으로 저장되었다. -> 아니다. 내가 잘못 봤다.
    * 일단 "This table contains..."는 들어갔지만 p16은 소제목이 중간에 표를 잘라 버렸다. 
    * ```python
```