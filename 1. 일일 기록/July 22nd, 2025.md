---
title: "July 22nd, 2025"
created: 2025-07-22 04:35:29
updated: 2025-07-23 20:43:11
---
  * 04:36 기상
  * 할 일
    * pymupdf4llm과 김희민 매니저가 처리한 결과 비교. 과연 중첩 표 처리하는 것이 어느 것이 낫나.
      * markdown 결과를 일일이 비교
      * 차이가 없다면?
    * 표 안에 표가 있는 칸을 처리해서 표에 해당하는 글을 지우고 따로 뺀 표를 가리키도록 치환.
  * 명경지수 -> 명징한 생각
  * 04:36 일단 김희민 매니저가 수정한 부분을 빨리 복사해서 주말에 돌려볼 수 있게 준비해야 한다.
  * 05:28 tableDetector 패키지가 있다. 조사 필 -> 알고 보니 김희민 매니저가 추가한 것. AI가 작성했으리라...
  * 08:07 cig 3
  * 08:20 단위테스트 결과 파일 올리는 방법
    * 오른쪽 위 "+" 표시 클릭
    * 다른 매크로 선택
    * 오른쪽 위 상자에 expand 입력
    * 여기를 클릭하여 펼치기(click here to expand)를 삽입하면 접고 펼칠 수 있는 상자가 뜸.
  * 08:29 pymupdf4llm과 김희민(이하 khm) 매니저 중첩표 작업 결과 비교 시작
    * p6 아래쪽 박스 안에 테이블 있는 것.
      * pymupdf4llm은 제목과 박스안에 있는 일반 글을 제대로 뽑아내지 못함.
      * 둘 다 해당 표를 markdown으로 표시했지만 맨 왼쪽 열이 빠짐. 다만 khm은 테이블 표시 막대 없지만, 표 안의 내용을 다 출력함.
    * p7 열병합되어 있는 표를 pymupdf4llm은 행병합으로 잘못 표기. khm은 그냥 공백.
    * p9 pymupdf4ll은 제목 빠진 표만 남김. khm은 제목도 추출
    * p16 여기는 오히려 pymupdf4llm이 낫다. 중첩표 동일하게 추출. 위에서도 반복되지만 병합칸은 p7 열병합만 빼면 pymupdf4llm이 낫다.
    * p18 pymupdf4llm은 그림에 있는 표를 아예 추출하지 못했고 kmh는 추출하긴 했는데 표 형식이 아님. 열병합 표는 p7과 동일.
    * p19 pymupdf4llm은 로밍 다음 칸을 행병합으로 처리한 문제와 두 번째 표 열병합을 행병합으로 처리한 문제가 있음.
    * pymupdf4llm도 중첩표 추출 다했지만 순서가 부모-자식이 아니고 자식이 먼저 2개 나오고 부모 그리고 자식.
    * 결론
      * 중첩표 추출은 둘 다 한다. pymupdf4llm은 자식 표 나열순서가 안 맞음. 자식 표 이름 잘 붙이고 가리키기만 하면 되지 않을까?
      * 병합칸 처리는 pymupdf4llm이 조금 더 낫다. 일부에서 병합을 잘못 해석.
      * 모든 글을 추출하는 것은 khm이 훨씬 나음.
      * kmh를 기본으로 하되 글자를 추출하는 부분은 둘 다 동일할 것으로 짐작되고 이 부분이 kmh에서 어딘지 찾아서 수정하면 될 듯.
  * 09:31 자식 표가 있는 칸에서 자식 표 지우고 지시자 넣는 방법 조사 시작
    * to_markdown 결과에 모든 내용이 있다.
      * dictionary
        * ```json
{
    'tables': [
        {
            'bbox': (x0, y0, x1, y1),  # Table boundary coordinates
            'row_count': 3,
            'col_count': 3
        }
    ],
    'text': '...'  # Markdown content
}```
      * p20에 있는 메타데이터 중 tables의 bbox에 있는 값으로 그림을 그릴 수 있는 html 만듦.
        * ```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rectangle Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        canvas {
            background-color: white;
            border: 2px solid #333;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .info {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 600px;
        }
        .rect-info {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
            font-family: monospace;
        }
        .rect-info span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rectangle Visualization</h1>
        <canvas id="canvas" width="600" height="720"></canvas>
        <div class="info">
            <h2>Rectangle Coordinates</h2>
            <div class="rect-info">
                <span style="background-color: rgba(255, 99, 132, 0.5);"></span>
                Rectangle 1: (54.6, 40.86, 551.17, 689.72)
            </div>
            <div class="rect-info">
                <span style="background-color: rgba(54, 162, 235, 0.5);"></span>
                Rectangle 2: (130.77, 95.12, 541.52, 150.66)
            </div>
            <div class="rect-info">
                <span style="background-color: rgba(255, 206, 86, 0.5);"></span>
                Rectangle 3: (130.77, 196.60, 541.52, 293.69)
            </div>
            <div class="rect-info">
                <span style="background-color: rgba(75, 192, 192, 0.5);"></span>
                Rectangle 4: (130.77, 359.12, 541.52, 660.83)
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Rectangle data with coordinates (x0, y0, x1, y1)
        const rectangles = [
            {
                coords: [54.6, 40.86, 551.17, 689.72],
                color: 'rgba(255, 99, 132, 0.5)',
                label: '1'
            },
            {
                coords: [130.77, 95.12, 541.52, 150.66],
                color: 'rgba(54, 162, 235, 0.5)',
                label: '2'
            },
            {
                coords: [130.77, 196.60, 541.52, 293.69],
                color: 'rgba(255, 206, 86, 0.5)',
                label: '3'
            },
            {
                coords: [130.77, 359.12, 541.52, 660.83],
                color: 'rgba(75, 192, 192, 0.5)',
                label: '4'
            }
        ];

        // Draw grid
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let i = 0; i <= canvas.width; i += 50) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, canvas.height);
            ctx.stroke();
        }
        for (let i = 0; i <= canvas.height; i += 50) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(canvas.width, i);
            ctx.stroke();
        }

        // Draw rectangles
        rectangles.forEach((rect, index) => {
            const [x0, y0, x1, y1] = rect.coords;
            const width = x1 - x0;
            const height = y1 - y0;

            // Fill rectangle
            ctx.fillStyle = rect.color;
            ctx.fillRect(x0, y0, width, height);

            // Draw border
            ctx.strokeStyle = rect.color.replace('0.5', '1');
            ctx.lineWidth = 2;
            ctx.strokeRect(x0, y0, width, height);

            // Draw label
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(rect.label, x0 + width / 2, y0 + height / 2);
        });

        // Draw coordinate labels
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        
        // X-axis labels
        for (let i = 0; i <= 600; i += 100) {
            ctx.fillText(i, i - 5, canvas.height - 5);
        }
        
        // Y-axis labels
        ctx.textAlign = 'left';
        for (let i = 0; i <= 700; i += 100) {
            ctx.fillText(i, 5, i + 5);
        }
    </script>
</body>
</html>```
  * 10:23 cig 4
  * 10:26 오늘 아침에 research로 돌린 것이 답이 될 수 있겠다.  khm 소스 분석
    * 각 페이지마다 _process_nested_tables(basic_markdown)를 실행해서 최종 결과 enhanced_markdown 얻음.
      * _detect_tables_with_multiple_methods로 후보 표 추출
      * _analyze_parent_child_relationship(table_candidates)로 parent_map 얻음
      * 표 순서 정리
      * 부모, 자식 표 markdown 찾아서 basic_markdown에 enhanced_markdown에 추가 -> 이 부분을 수정해서 enhanced_markdown만 넘기도록 해야 한다.
  * 10:58 쉬는 중에 잠깐 든 생각. 이렇게 하면 될 거를 왜 이렇게 해맸을까? 어디서 잘못된 거지?
    * pymupdf4llm의 markdown이 결과를 내놓는다는 것을 알았는데 거기서부터 출발했어야 하는데 처음에 너무 깊이 들어가려고 하지 않았나? 그래서 막 로그를 추가하느라 시간 낭비했고. 문제 정의를 처음에 잘못했다. 내가 해결해야 하는 문제는 중첩표를 어떻게 끄집어 내느냐가 아니었다. 중첩표는 애초에 잘 처리했다. 다만 markdown에서 자식 표에 해당하는 내용을 어떻게 처리할지부터 고민했어야 했다.
    * khm의 로그가 너무 많았다.
  * 11:04 khm에 로그가 지나치게 많아서 정리 시작. enhanced_markdown만 로그에 남기도록 시도.
    * basic과 enhanced는 동일하다! 그럼 왜 enhanced인 거지?
    * to_markdown부터 다시 시작
      * markdown_pages =to_markdown(doc, page_chunks=True) -> 이 때 metadata에 테이블 정보가 들어간다.
      * page_text = markdown_pages[page_num].get("text", "") 으로 글을 일단 추출
  * 12:52 cig 5
  * 13:05 raw, basic, enchanced 비교 계속
    * p6도 모두 동일
    * p19 동일
    * 결론: 모두 동일하니 raw만 가지고 바로 작업해도 된다. 그럼 enhanced는 왜?
  * 13:13 자식 표가 있는 자리를 자식 표 가리키는 글로 바꾸기 준비
    * pdf2md.py를 수정해서 nested_table_process.py 만들기
  * 15:31 역시 AI를 그대로 믿으면 안돼...제대로 안 도는데..
  * 15:34 cig 6
  * 15:52 테이블 전처리 설계
    * to_markdown은 custom_pdf를 이용
    * to_markdown(최신것? 아니면 khm?) 결과를 전처리에 던지기
  * 16:23 일단 앞으로 개발할 때 원활하게 하기 위해서 custom_pdf에 속한 디렉토리를 services로 다 옮김. 이제부터 services 디렉토리에서 모두 실행 가능. "(sys.path.append(str(Path(*file*).parent)))"가 실행 프로그램에 있어야 패키지 찾는 에러가 나지 않는다.
  * 17:29 아...어떤 표가 자식 표를 포함하는지 알 방법을 로직에 넣어야겠다. -> 7/23 수요일에 pymupdf4llm으로 AI 도움을 받아서 처리.
  * 17:33 cig 7
  * 22:06 cig 10