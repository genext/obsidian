---
title: "July 18th, 2025"
created: 2025-07-18 06:53:43
updated: 2025-08-04 19:18:35
---
  * 오늘 할 일
    * 중첩표 처리 로직 파악 및 변경?
  * 명경지수 -> 명징한 생각
  * 07:11 cig 1
  * parms.tabdms가 파이썬 테이블 객체? 그렇지 않다면 테이블 만들어서 복사하면서 값을 전처리?
  * 09:00 p203100 가상환경을 실행하고 테스트 프로그램 돌렸지만 pymupdf ModuleNotFoundError가 난다. 그냥 내 가상환경에서 실행해서 일하기로...
    * 분명 p203100 가상환경에서도 pip list하면 pymupdf가 있는데 왜 ModuleNotFoundError가 나지?
  * 09:29 cig 3
  * 09:38 llama/pdf_markdown_reader.py의 class PDFMarkdownReader(BaseReader).load_data 분석 시작
    * **def load_data(self, file_path: Union[Path, str], pages: Optional[List[int]] = None, \*\*kwargs: Any) -> List[llamaIndexDocument]:**
      * doc = FitzDocument(str(file_path))
      * hdr_info = IdentifyHeaders(doc)
      * markdown_pages = to_markdown(doc, page_chunks = True)
      * ```python
# 처리할 페이지 범위 결정
if pages is None:
  # 모든 페이지 처리
  page_range = range(len(doc))
else:
  # 특정 페이지만 처리 (1-based -> 0-based)
  page_range = [p - 1 for p in pages if 1 <= p <= len(doc)]
  if not page_range:
    raise ValueError(f"...")```
      * page_range = range(len(doc)) or page_range = [p - 1 for p in pages if 1 <= p <= len(doc)]
        * 왜 인덱스를 0부터 시작하게 바꾸지? -> 인자로 받는 pages 리스트 색인값 때문
      * for loop: page_range. 글만 추출하기 위해
        * ```python
for page_num in page_range:
  page = doc[page_num]
  # page_markdown이 dict라면 text 필드만 사용
  if isinstance(markdown_pages[page_num], dict):
    page_text = markdown_pages[page_num].get("text", "")
  else:
    page_text = markdown_pages[page_num]

  # Enhance with nested table detection
  enhanced_markdown = self._process_nested_tables(page, page_text, hdr_info)```
        * create document
          * ```python
  metadata = {
    "format": doc.metadata.get("format", ""), 
    ..., 
    page: page_num + 1, 
    "total_pages": len(doc),
    "file_path": str(file_path),
  }
  
  if self.meta_filter:
    metadata = self.meta_filter(metadata)
  
  document = LlamaIndexDocument(text = enhanced_markdown, metadata= metadata)
  documents.append(document)

doc.close()
return documents```
    * **def _process_nested_tables(self, page: pymupdf.Page, basic_markdown: str, hdr_info: IdentifyHeaders)**
      * ```python
def _process_nested_tables(self, page: pymupdf.Page, basic_markdown: str, hdr_info: IdentifyHeaders) -> str:
  table_candidates: List[Dict] = self._detect_tables_with_multiple_methods(page)
  if not table_candidates:
    return basic_markdown
  parent_map = self._analyze_parent_child_relationships(table_candidates)
  # 중첩된 테이블을 순서대로 정렬
  nested_tables = []
  for idx, table in enumerate(table_candidates):
    if idx in parent_map and parent_map[idx] is not None:
      nested_tables.append((idx, table, parent_map[idx]))
  nested_tables.sort(
    key = lambda x: (x[1].get("rect", [0,0,0,0])[1],
                     x[1].get("rect", [0,0,0,0])[0],
                    )
  )
  table_markdowns = []
  table_counter = 1
  nested_counter = 1

  # 모든 테이블에 번호 부여
  for idx, table in enumerate(table_candidates):
    md: str = self._convert_table_to_markdown(table, page, hdr_info, table_counter)
    table_markdowns.append(md)
    table_count += 1

  # 중첩된 테이블 정보를 순서대로 추가
  enhanced_markdown = basic_markdown
  for nested_idx, nested_table, parent_idx in nested_tables:
    parent_info: str = self._get_parent_table_info_for_index(netsted_idx, table_candidates, parent_map, nested_counter)
    # 부모 테이블과 중첩 테이블의 마크다운 찾기
    parent_table_number = parent_idx + 1 # 0-based to 1-based
    nested_table_number = nested_idx + 1
    
    parent_md = (table_markdowns[parent_idx] if parent_idx < len(table_markdowns) else "")
    nested_md = (table_markdowns[nested_idx] if nested_idx < len(table_markdowns) else "")
    # 중첩된 테이블 정보 블록 생성
    nested_info = f"""   {parent_info}   """

    if self.show_parent_table_markdown:
      nested_info += f"**{self.parent_table_label} ({self.table_label} #{parent_table_number}):**\n{parent_md}\n\n"

    nested_info += f"**{self.nested_table_label} ({self.table_label} #{nested_table_number}):**\n{nested_md}\n\n"

    # 중첩된 테이블 정보를 마크다운에 추가
    enhanced_markdown += nested_info
    nested_counter += 1
  return enhanced_markdown

def _convert_table_to_markdown(
  self,
  table_candidates: Dict[str, Any],
  page: pymupdf.Page,
  hdr_info: IdentifyHeaders,
  table_index: int,
) -> str:
  # convert a table candidate to markdown format with source information
  cells = table_candidate.get("cells", [])
  if not cells:
    return ""

  # Get table source info
  table_rect = table_candidate.get("rect", (0,0,0,0))
  page_number = page.number + 1

  # calculate table structure
  max_row = max(cell["row"] for cell in cells)
  max_col = max(cell["col"] for cell in cells)
  rows = max_row + 1
  cols = max_col + 1

  # Get sample cell content for description
  sample_cells = [cell["text"][:50] for cell in cells[:3] if cell.get("text")]
  content_preview = " | ".join(sample_cells) if sample_cells else "No content"

  # create detailed source header
  source_info = (
    f"**{self.table_label} {table_index}** "
    f"({self.page_label} {page_number}, {rows}x{cols} {self.cells_label})\n"
    f" {self.position_label}: {self._format_rect(table_rect)}\n"
    f" {self.content_preview_label}: {content_preview}..."
  )

  # group cells by row
  grid = [[None for _ in range(cols)] for _ in range(rows)]

  for cell in cells:
    row, col = cell["row"], cell["col"]
    if 0 <= row < rows and 0 <= col < cols:
      grid[row][col] = cell

  # convert to markdown table
  markdown_table = []
  나머지는 사진 -> 집에 가서
  
  ```
      * IdentifyHeader가 클래스인데...좀 더 분석
      * table_candidates: List[Dict] = self.**_detect_tables_with_multiple_methods(page)**
        * multi_column.py의 find_table_candidates 분석. 거기에 아래쪽에 있는 nested_tables.sort(...)와 비슷한 코드가 있음.
      * parent_map: Dict[int, int] = self.**_analyze_parent_child_relationships(table_candidates)**
      * 중첩된 테이블을 순서대로 정렬
        * for-loop of table-candidates
          * 만약 parent이면
            * nested_tables.append((idx, table, parent_map[idx]))
      * 중첩된 테이블을 위치 순서대로 정렬
        * nested_tables.sort(key = lambda x: (x[1].get("rect", [0,0,0,0])[1], x[1].get("rect", [0,0,0,0])[0],))
        * sort 함수
      * 모든 테이블에 순차 번호 부여. for loop of table_candidates
        * md: str = self.**_convert_table_to_markdown(table, page, hdr_info, table_counter)**
      * 중첩된 테이블 정보를 순서대로 추가. for-loop of nested_tables
        * parent_info: str = self.**_get_parent_table_info_for_index(netsted_idx, table_candidates, parent_map, nested_counter)**
        * 부모 테이블과 중첩 테이블 마크다운 찾기
          * parent_md = (table_markdowns[parent_idx] if parent_idx < len(table_markdowns) else "")
          * nested_md = (table_markdowns[nested_idx] if nested_idx < len(table_markdowns) else "")
        * nested_info = f"""   {parent_info}   """
        * 인자 중 show_parent_table_markdown에 True면, nested_info에 부모 테이블 정보도 추가
        * enhanced_markdown += nested_info
        * nested_count += 1
        * 여기서부터는 자료 구조를 종이에 정리할 필요가 있다. 
        * pymupdf.Page 데이터형 분석
        * llama_index.core.readers.base의 BaseReader 클래스가 테이블을 판별해서 추출할 수 있는 듯.
        * helpers.multi_column의 TableDetector, column_boxes
      * return enhanced_markdown
    * def _detect_tables_with_multiple_methods(self, page: pymupdf.Page) -> List[Dict]
      * ```python
def _detect_tables_with_multiple_methods(self, page: pymupdf.Page) -> List[Dict]:
  table_candidates = []
  for method in self.table_detection_methods:
    try:
      if method == "lines":
        table_detector = TableDetector(page)
        h_lines, v_lines = table_detector.detect_lines()
        if h_lines or v_lines:
          candidates = table_detector.find_table_candidates()
          for candidate in candidates:
            candidate["detection_method"] == "lines"
            table_candidates.append(candidate)
        elif method == "test":
          text_candidates = self._detect_tables_by_text_analysis(page)
          for candidate in text_candidates:
            candidate["detection_method"] == "text"
            table_candidates.append(candidate)
        elif method == "hybrid":
          hybrid_candidates = self._detect_tables_hybrid(page)
          for candidate in hybrid_candidates:
            candidate["detection_method"] == "hybrid"
            table_candidates.append(candidate)
    except Exception as e:
      print(...)
      continue
  return self._remove_duplicate_tables(table_candidates)
    
def _detect_tables_by_text_analysis(self, page: pypmupdf.Page) -> List[Dict]:
  # 텍스트 블록 분석을 통한 테이블 감지
  text_blocks = page.get_text("dict")["blocks"]
  table_candidates = []
  # 텍스트 블록들을 행과 열로 그룹화
  rows = self._group_text_blocks_into_rows(text_blocks)
  # 행들을 테이블로 그룹화
  tables = self._group_rows_into_tables(rows)
  for table in tables:
    table_candidates.append(
      {
        "rect": table["rect"],
        "cells": table["cell"],
        "row_count": table["row_count"],
        "col_count": table["col_count"],
        "text_based": True,
      }
    )
  return table_candidates

def _detect_tables_hybrid(self, page: pymupdf.Page) -> List[Dict]:
  # 라인 기반 감지
  table_detector = TableDetector(page)
  line_candidates = table_detector.find_table_candidates()
  # 텍스트 기반 감지
  text_candidates = self._detect_tables_by_text_analysis(page)
  # 두 결과를 결합하고 중복 제거
  all_candidates = line_candidates + text_candidates
  return self._remove_duplicate_tables(all_candidates)

def _group_text_blocks_into_rows(self, text_blocks: List[Dict]) -> List[List[Dict]]:
  # 텍스트 블록을 y 좌표로 정렬
  sorted_blocks = sorted(
    text_blocks, key = lambda b: b.get("bbox", [0,0,0,0])[1]
  )
  rows = []
  current_row = []
  current_y = None
  for block in sorted_blocks:
    bbox = block.get("bbox", [0,0,0,0])
    y = bbox[1]
    if current_y is None or abs(y - current_y) <= self.y_tolerance:
      current_row.append(block)
      current_y = y
    else:
      if current_row:
        rows.append(current_row)
      current_row = [block]
      current_y = y
    if current_row:
      rows.append(current_row)
  return rows

def _group_rows_into_tables(self, rows: List[List[Dict]]) -> List[Dict]:
  tables =[]
  current_table = None
  for row in rows:
    if self._is_table_row(row):
      if current_table is None:
        current_table = {
          "rows": [],
          "rect": self._calculate_table_rect(row),
          "cells": [],
        }
      current_table["rows"].append(row)
      current_table["cells"].extend(self._extract_cells_from_row(row))
    else:
      if current_table:
        current_table["row_count"] = len(current_table["rows"])
        current_table["col_count"] = max(
          len(row) for row in current_table["rows"]
        )
        tables.append(current_table)
        current_table = None

  if current_table:
    current_table["row_count"] = len(current_table["rows"])
    current_table["col_count"] = max(len(row) for row in current_table["rows"])
    tables.append(current_table)
  return tables

def _is_table_row(self, row: List[Dict]) -> bool:
  if len(row) < 2:
    return False

  # 텍스트 블록들이 수평으로 정렬되어 있는지 확인
  x_positions = [block.get("bbox", [0,0,0,0])[0] for block in row]
  x_positions.sort()

  # x 좌표 간격이 일정한지 확인
  if len(x_positions) >= 2:
    intervals = [
      x_positions[i + 1] - x_positions[i] for i in range(len(x_positions) - 1)
    ]
    avg_interval = sum(intervals) / len(intervals)
    variance = sum((i - avg_interval) ** 2 for i in intervals) / len(intervals)
    # 분산이 작으면 일정한 간격으로 간주
    return variance < self.x_variance_threshold
  return False

def _calculate_table_rect(self, row: List[Dict]) -> tuple:
  x_coords =[]
  y_coords = []

  for block in row:
    bbox = block.get("bbox", [0,0,0,0])
    x_coords.extend([bbox[0], bbox[2]])
    y_coords.extend([bbox[1], bbox[3]])
  return (min(x_coords), min(y_coords), max(x_coords), max(y_coords))

def _extract_cells_from_row(self, row: List[Dict]) -> List[Dict]:
  cells = []
  for i, block in enumerate(row):
    bbox = block.get("bbox", [0,0,0,0])
    text = block.get("text", "")
    cells.append(
      {
        "rect": bbox,
        "text": text,
        "row": 0, # 첫 번째 행
        "col": i,
        "images": [],
      }
    )
  return cells

def _remove_duplicate_tables(self, table_candidates: List[Dict]) -> List[Dict]:
  unique_tables = []
  for candidate in table_candidates:
    is_duplicate = False
    for existing in unique_tables:
      # 위치가 겹치는지 확인
      if self._rects_overlap(candidate["rect"], existing["rect"]):
        # 내용 유사도 확인
        similarity = self._calculate_table_similarity(candidate, existing)
        if similarity > self.duplicate_similarity_threshold:
          is_duplicate = True
          break
    if not is_duplicate:
      unique_table.append(candidate)
  return unique_tables

def _rect_overlap(self, rect1: tuple, rect2: tuple) -> bool:
  x1_1, y1_1, x2_1, y2_1 = rect1
  x1_2, y1_2, x2_2, y2_2 = rect1

  return not(x2_1 < x1_2 or x2_2 < x1_1 or y2_1 < y1_2 or y2_2 < y1_1)

def _calcudate_table_similarity(self, table1: Dict, table2: Dict) -> float:
  # 셀 내용 비교
  cell1 = table1.get("cells", [])
  cell2 = table2.get("cells", [])
  if not cell1 or not cell2:
    return 0.0

  # 셀 내용을 문자열로 결합
  content1 = " ".join([cell.get("text","") for cell in cells1])
  content2 = " ".join([cell.get("text","") for cell in cells2])
  return self._calculdate_content_similarity(content1, content2)

def _calculate_content_similarity(self, content1: str, content2: str) -> float:
  if not content1 or not content2:
    return 0.0

  # 간단한 단어 기반 유사도 계산
  words1 = set(content1.lower().split())
  words2 = set(content2.lower().split())
  if not word1 or not words2:
    return 0.0

  intersection = words1.intersection(words2)
  union = words1.union(words2)

  return len(intersection)/len(union) if union else 0.0

def _anaylyze_parent_child_relationships(
  self, table_candidates: List[Dict]
) -> Dict[int, int]:
  parent_map = {}
  for i, child_table in enumerate(table_candidates):
    best_parent = None
    best_score = 0
    for j, parent_table in enumerate(table_candidates):
      if i == j:
        continue

      # 다양한 기준으로 부모-자식 관계 점수 계산
      score = self._calculate_parent_child_score(child_table, parent_table)

      if (
        score > best_score
        and score > self.parent_child_relationship_threshold
      ):
        best_score = score
        best_parent = j

    parent_map[i] = best_parent
  return parent_map

def _calculate_parent_child_score(self, child: Dict, parent: Dict) -> float:
  score = 0.0
  # 1. 위치 관계(자식이 부모 안에 있는지)
  if self._rect_contains(parent["rect"], child["rect"]):
    score += 0.4

  # 2. 크기 관계 (부모가 자식보다 큰지)
  parent_area = (parent["rect"][2] - parent["rect"][0]) * (parent["rect"][3] - parent["rect"][1])
  child_area = (child["rect"][2] - child["rect"][0]) * (child["rect"][3] - child["rect"][1])

  if (
    parent_area > child_area * self.parent_area_ratio
  ): # 부모가 자식보다 설정된 비율 이상 클 때
    score += 0.3
  # 3. 내용 관련성
  content_similarity = self._calculate_content_relatedness(child, parent)
  score += content_similarity * 0.3

  return score

def _rect_contains(self, outer: tuple, inner: tuple) -> bool:
  # check if outer rectangle contains inner rectangle
  return (
    outer[0] <= inner[0]
    and outer[1] <= inner[1]
    and outer[2] <= inner[2]
    and outer[3] <= inner[3]
  )

def _calculate_content_relatedness(self, child: Dict, parent: Dict) -> float:
  child_content = " ".join(
    [cell.get("text", "") for cell in child.get("cells", [])]
  )
  parent_content = " ".join(
    [cell.get("text", "") for cell in parent.get("cells", [])]
  )
  # 공통 키워드 찾기
  child_words = set(child_content.lower().split())
  parent_words = set(parent_content.lower().split())
  if not child_words or not parent_words:
    return 0.0
  common_words = child_words.intersection(parent_words)
  total_words = child_words.union(parent_words)
  return len(common_words)/len(total_words) if total_words else 0.0

def _get_parent_table_info_for_index(
  self,
  nested_index: int,
  table_candidates: List[Dict],
  parent_map: Dict[int, int],
  nested_table_number: int = 1,
) -> str:
  # Extract parent table info for nested tables using table index
  if nested_index not in parent_map or parent_map[nested_index] is None:
    return f"\n**{self.nested_table_label} #{nested_table_number} ({self.extraction_info_prefix} - {self.parent_table_label} extraction)**\n"
  parent_index = parent_map[nested_index]
  parent_table = table_candidates[parent_index]
  nested_table = table_candidates[nested_index]
  parent_cells = parent_table.get("cells", [])

  if not parent_cells:
    return f"\n**{self.nested_table_label} #{nested_table_number} ({self.extraction_info_prefix} - {self.parent_table_label} extraction)**\n"

  # 부모 테이블 정보 추출
  parent_rect = parent_table.get("rect", (0,0,0,0))
  nested_rect = nested_table.get("rect", (0,0,0,0))

  # 부모 테이블 헤더 추출(첫 행)
  parent_header = ""
if parent_cells:
  content_cells = parent_cells[:3] # 최대 3개 셀
  content_texts = [cell.get("text", "").strip() for cell in content_cells]
  parent_content = " | ".join([text for text in content_texts if text])
  # 중첩된 테이블 위치 찾기
  nested_position = self._find_nested_table_position_in_parent(
    nested_table, parent_table
  )

  # 중첩 비율 계산
  parent_area = (parent_rect[2] - parent_rect[0]) * (
    parent_rect[3] - parent_rect[1]
  )
  nested_area = (nested_rect[2] - nested_rect[0]) * (
    nested_rect[3] - nested_rect[1]
  )
  nested_ration = (nested_area / parent_area * 100) if parent_area > 0 else 0

  # 감지 방식
  detection_method = parent_table.get("detection_method", "unknown")
  nested_detection_method = nested_table.get("detection_method", "unknown")

  return (
    f"\n**{self.nested_table_label} #{nested_table_number} ({self.extraction_info_prefix} - {self.parent_table_label} extraction)**\n"
    f"**{self.extraction_info_prefix}:**\n"
    f"..."
    ...
  )```
    * **def _analyze_parent_child_relationships(self, table_candidates: List[Dict]) -> Dict[int, int]**
      * 부모 자식 관계를 계산을 통해서 찾는데 부모 표만 찾는 것 같다...
  * 11:17 cig 4
  * 16:00 김희민 매니저와 2시간 넘게 얘기한 것 같다.
    * 나와 비슷한 난청, 성장 과정
  * 16:10 cig 5
  * 19:29 cig 6
