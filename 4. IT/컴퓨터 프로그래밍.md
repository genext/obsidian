---
title: "컴퓨터 프로그래밍"
created: 2025-09-14 10:52:51
updated: 2025-09-14 16:46:10
---
  * 절차적
    * C #[[c++|c/c++]]
    * OOP
      * C++ #[[c++|c/c++]]
      * Java 
  * 함수형
    * 핵심 철학
      * 함수형 프로그래밍은 완전히 새로운 것이 아니라, 이미 사용하고 있는 좋은 프로그래밍 관습들을 체계화한 패러다임. 상태 변경을 최소화하고, 작고 조합 가능한 함수들로 문제를 해결하는 접근 방식.
      * immutability
        * 변수 상태를 바꾸지 않고 불변하는 새 변수 생성
          * ```java
// 명령형 방식
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");

// 함수형 방식
List<String> names = List.of("Alice", "Bob");
List<String> newNames = Stream.concat(names.stream(), Stream.of("Charlie"))
                              .collect(toList());

// Imperative way - modifying state
public void processUsers(List<User> users) {
    for (User user : users) {
        user.setActive(true);        // Modifying the original object
        user.setLastLogin(new Date()); // Side effect!
    }
}

// Functional way - creating new state
public List<User> processUsers(List<User> users) {
    return users.stream()
        .map(user -> user.withActive(true)           // Returns new User object
                        .withLastLogin(new Date()))   // Instead of modifying original
        .collect(toList());
}```
        * 성능이 중요할 때는 혼합 사용
          * ```java
// Use mutable for performance-critical, localized operations
private List<Result> processLargeDataset(Stream<Data> data) {
    List<Result> results = new ArrayList<>();  // Mutable, local scope
    data.forEach(item -> {
        if (expensiveCondition(item)) {
            results.add(transform(item));
        }
    });
    return Collections.unmodifiableList(results); // Return immutable view
}

// Use immutable for public APIs and shared state
public List<User> addUser(List<User> existingUsers, User newUser) {
    return Stream.concat(existingUsers.stream(), Stream.of(newUser))
                 .collect(toList()); // Safe from external modification
}```
      * pure function: no side effect.
        * ```java
// 순수 함수
public int add(int a, int b) {
    return a + b;
}

// 비순수 함수 (전역 상태 변경)
private int counter = 0;
public int addAndCount(int a, int b) {
    counter++; // 부작용
    return a + b;
}```
      * higher-order function
        * Think of it as **levels of abstraction**:
          * **0th order**: Raw data (5, "hello", true)
          * **1st order**: Functions that work on data (`add(5, 3)`, `length("hello")`)
          * **2nd order**: Functions that work on 1st-order functions
          * **3rd order**: Functions that work on 2nd-order functions
          * And so on...
        * **First-order**: Functions that work on basic values (numbers, strings, etc.)
          * ```plain text
f(x) = x + 1    // Takes a number, returns a number```
        * **Higher-order**: Functions that work on OTHER FUNCTIONS
          * ```plain text
∫ f(x) dx       // Integration takes a function f(x) and returns another function
d/dx f(x)       // Differentiation takes a function and returns its derivative function```
        * Think of functions as "first-class citizens" - they can be passed around like any other value
        * **Takes other functions as parameters**, OR
        * **Returns a function as its result**
        * 예
          * ```java
// map, filter, reduce 등
list.stream()
    .filter(x -> x > 0)
    .map(x -> x * 2)
    .reduce(0, Integer:sum);```
        * 만들기
          * ```java
// This function takes another function as a parameter
public static <T> List<T> filterList(List<T> list, Predicate<T> condition) {
    return list.stream()
               .filter(condition)  // Using the passed function
               .collect(toList());
}

// Usage:
List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);
List<Integer> evens = filterList(numbers, x -> x % 2 == 0);  // Pass function as argument
List<Integer> big = filterList(numbers, x -> x > 3);         // Pass different function

// This function RETURNS another function
public static Function<Integer, Integer> createMultiplier(int factor) {
    return x -> x * factor;  // Returns a function
}

// Usage:
Function<Integer, Integer> double = createMultiplier(2);  // Get a doubling function
Function<Integer, Integer> triple = createMultiplier(3);  // Get a tripling function

int result1 = double.apply(5);  // 10
int result2 = triple.apply(5);  // 15```
      * function composition
      * abstraction over control flow
        * Instead of writing loops everywhere, you abstract the iteration pattern
        * ```java
// Instead of always writing for-loops
for (int i = 0; i < list.size(); i++) {
    if (someCondition(list.get(i))) {
        result.add(transform(list.get(i)));
    }
}

// You describe WHAT you want, not HOW to loop
list.stream()
    .filter(this:someCondition)
    .map(this::transform)
    .collect(toList());```
    * 절차형/함수형 사고방식 비교
      * ```java
// 절차적 방식
int sum = 0;
for (int num : numbers) {
    if (num % 2 == 0) {
        sum += num * num;
    }
}

// 함수형 방식
int sum = numbers.stream()
    .filter(n -> n % 2 == 0)
    .mapToInt(n -> n * n)
    .sum();```
    * 함수형은 **"무엇을(what)"** 에 집중하고, 절차형은 **"어떻게(how)"** 에 집중.
    * 실제 장점들
      * **1. 예측 가능성**: 순수 함수는 테스트하기 쉽고 디버깅이 용이.
      * **2. 동시성 안전**: 불변 데이터는 스레드 안전 문제 X.
      * **3. 모듈성**: 작은 함수들의 조합으로 복잡한 로직을 표현 가능.
    * java 에서 채택한 것: Stream API, Lambda, Optional
      * Predicate<T>
        * is for functions that return a **boolean** (true/false)
        * ```java
Predicate<Integer> isEven = x -> x % 2 == 0;  // Returns boolean

List<Integer> filterNumbers(List<Integer> numbers, Predicate<Integer> test) {
    return numbers.stream().filter(test).collect(toList());
}

filterNumbers(List.of(1, 2, 3, 4), x -> x % 2 == 0);  // Returns [2, 4]```
      * Function<T, R>
        * is for functions that transform one type to another:
        * ```java
Function<Integer, Integer> doubler = x -> x * 2;  // Returns Integer
Function<Integer, String> toString = x -> "Number: " + x;  // Returns String

processAll(List.of(1, 2, 3), x -> x * 2);     // 1→2, 2→4, 3→6
processAll(List.of(1, 2, 3), x -> x + 10);    // 1→11, 2→12, 3→13```
      * 그 외 다수
  * 비결정적
    * AI는 행렬연산과 확률 분포를 이용한다.