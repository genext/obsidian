---
title: "개발 고민"
created: 2024-10-17 20:22:16
updated: 2024-10-21 09:55:25
---
  * 경력이 많은 개발자라면 공통 모듈 범위를 항상 생각하고 공통 모듈을 만들어 낼 줄 알아야겠지?
    * 보안
      * front
        * 상태 관리(redux, recoil 등): 토큰, 로그인 정보 등
        * 메뉴
        * 검색 조건: 디지털 바우처 금결원 소스 확인
      * back
        * API 호출 결과(response)
          * 그냥 string도 좋고 model도 좋고 여러가지가 있다. 다만 공통 형식이 있는 것이 좋다.
          * Error Message
            * rest controller
              * ```java
 @PostMapping(path = "/readList")
    public ResponseEntity<?> readList(@RequestBody GridRequest gridRequest) {
        if ( ObjectUtils.isEmpty(gridRequest))  {            
             return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ErrorMessage.builder().status(String.valueOf(HttpStatus.BAD_REQUEST)).message("검색필드가 누락되었습니다.").build());
        }        
        paymentManageService.readList(gridRequest, null);
        return ResponseEntity.ok().build();

    }```
            * type definition
              * ```java
package kr.or.cbdc.infrastructure.error.model;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
public class ErrorMessage {
    private String status;
    private String message;

    public ErrorMessage(String status, String message) {
        this.status = status;
        this.message = message;
    }

    public String toJson() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        String jsonString = mapper.writeValueAsString(this);
        return jsonString;

    }

}
```
          * 위 타입을 상속하여 ApiResponse를 추가 정의
            * rest controller
              * ```java
@Operation(summary = "0.1.3.5 바우처 승인 요청 상세", description = "바우처 승인 요청 상세")
    @GetMapping(path = "/deployRequestDetail")
    public ResponseEntity<ApiResponse<BaseMap>> deployRequestDetail(
            @RequestParam("deployRequestId") String deployRequestId) {
        if (deployRequestId == null || deployRequestId.trim().isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse.error(
                    String.valueOf(HttpStatus.BAD_REQUEST.value()), "바우처 ID가 없습니다."));
        }

        BaseMap results = vcDeployService.deployRequestDetail(deployRequestId);

        if (results != null && !results.isEmpty()) {
            return ResponseEntity.ok(ApiResponse.success(String.valueOf(HttpStatus.OK.value()), "상세 조회 완료", results));
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(ApiResponse.error(String.valueOf(HttpStatus.NOT_FOUND.value()), "일치하는 데이터가 없습니다."));
        }
    }
```
            * type definition
              * ```java
package kr.or.cbdc.config.messages;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

import lombok.EqualsAndHashCode;
import kr.or.cbdc.infrastructure.error.model.ErrorMessage;

@Data
@EqualsAndHashCode(callSuper = true)
@Schema(description = "공통 API 응답 객체")
public class ApiResponse<T> extends ErrorMessage {

    @Schema(description = "응답 성공 여부", example = "true")
    private boolean success;

    @Schema(description = "응답 데이터")
    private T data;

    public ApiResponse(String status, boolean success, String message, T data) {
        super(status, message);
        this.success = success;
        this.data = data;
    }

	// Factory method for success responses
    public static <T> ApiResponse<T> success(String status, String message, T data) {
        return new ApiResponse<>(status, true, message, data);
    }

    // Factory method for error responses
    public static <T> ApiResponse<T> error(String status, String message) {
        return new ApiResponse<>(status, false, message, null);
    }
}```
        * pagination
          * 위 기본 응답에 pagination을 추가할 경우.
          * backend
            * rest controller
              * ```java
@Operation(summary = "0.1.3.4 바우처 배포 검색", description = "Search deploy requests based on criteria")
    @GetMapping(path = "/searchDeployRequests")
    public ResponseEntity<ApiResponse<PageData>> searchDeployRequests(
            @ModelAttribute VcDeployRequestSearchDTO searchCriteria,
            HttpServletRequest request) {
        if (searchCriteria == null || searchCriteria.getPage() == null || searchCriteria.getLimit() == null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ApiResponse.error(
                    String.valueOf(HttpStatus.BAD_REQUEST.value()), "검색조건이 잘못 되었습니다."));
        }
        log.debug("+++++++ searchCriteria: {}", searchCriteria);
        String accessToken = authorizationService.extractToken(request.getHeader("Authorization"));
        BaseMapList results = vcDeployService.searchDeployRequests(searchCriteria, accessToken);
        PageData pageData = new PageData(results, searchCriteria.getPage(), searchCriteria.getLimit());
        log.debug("+++++++ pageData: {}", pageData);

        return ResponseEntity.ok(ApiResponse.success(String.valueOf(HttpStatus.OK.value()), "검색 완료", pageData));
    }```
            * type definition
              * PagingDTO: 요청 데이터 기본 타입
                * PaginDTO
                  * ```java
package kr.or.cbdc.config.paging;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@NoArgsConstructor
public class PagingDTO {

	@Schema(description = "페이지", example = "1")
	public Integer page;

	@Schema(description = "조회할 최대 행 수", example = "1000000")
	public Integer limit;

	@Schema(hidden = true)
	public Integer getOffset() {
		return (page - 1) * limit;
	}
}```
              * 실제 front에서 보낼 요청 타입
                * VcDeployRequestSearchDTO
                  * ```java
package kr.or.cbdc.application.voucherManage.vc.deploy.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import kr.or.cbdc.config.paging.PagingDTO;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@Data
@EqualsAndHashCode(callSuper = false)
@NoArgsConstructor
@Schema(description = "바우처 배포 요청 검색 DTO 객체")
public class VcDeployRequestSearchDTO extends PagingDTO {

	@Schema(description = "배포 요청 ID", example = "REQ123456")
	private String deployRequestId;

	@Schema(description = "바우처 이름", example = "Voucher A")
	private String voucherName;

	@Schema(description = "템플릿 유형", example = "C0040001")
	private String templateType;

	@Schema(description = "진행 상태", example = "C0090001")
	private String status;

	@Schema(description = "승인일 시작", example = "2024-09-03T00:00:00")
	private String createdAtStart;

	@Schema(description = "승인일 종료", example = "2024-09-03T00:00:00")
	private String createdAtEnd;

	@Schema(description = "회사 아이디", example = "COMP000000002")
	private String companyId;

	@Schema(description = "정렬 순서(asc, desc)", example = "desc")
	private String order;
}
```
              * 응답 데이터 타입 PageData
                * ```java
package kr.or.cbdc.config.messages;

import io.swagger.v3.oas.annotations.media.Schema;
import kr.or.cbdc.infrastructure.framework.core.support.collection.BaseMapList;
import lombok.Data;

@Data
@Schema(description = "공통 API 응답 객체")
public class PageData {

	public PageData(BaseMapList baseMapList, int pageNo, int pageSize) {
		if (baseMapList.size() > 0) {
			this.totalCount = Integer.parseInt(baseMapList.get(0, "totalCount").toString());
			this.list = baseMapList;
			this.currentPage = pageNo;
			this.limit = pageSize;
		}
	}

	@Schema(description = "페이지")
	int currentPage;

	@Schema(description = "페이지당 건수")
	int limit;

	@Schema(description = "전체 건수")
	int totalCount;

	@Schema(description = "리스트 데이터")
	BaseMapList list;
}
```
          * frontend
            * ```javascript
...
  useEffect(() => {
    if (accountStore.user?.companyId) handleSearch(currentPage, limit);
  }, [currentPage, limit, accountStore.user?.companyId]);

  const handleSearch = async (page: number, limit: number) => {
    const companyId = accountStore.user?.companyId || "";

    if (companyId === "") {
      return;
    }
    const searchCriteria = {
      voucherName: inputValue || undefined,
      templateType:
        templateTypeOption.selectedOption.value === "all"
          ? null
          : templateTypeOption.selectedOption.value,
      status:
        voucherStatus.selectedOption.value === "all"
          ? null
          : voucherStatus.selectedOption.value,
      order,
      page,
      limit,
    };

    setLoading(true);
    setError(null);

    try {
      const response = await SystemService.GET<WithPagination<VoucherRequest>>(
        VOUCHER_SEARCH_DEPLOY_REQUESTS,
        {
          params: searchCriteria,
        },
      );
...```
        * global error handler
        * filter(AOP)
        * Date type 데이터는 json serialization(Jackson)을 거치면 이렇게 [year, month, day, hour, minute, second] 배열로 바뀌어서 front로 간다. 
          * 이게 싫다면 response용 DTO를 만들어서 해당 Date 타입 속성에 @@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss")를 덧붙인다? 이건 웃기는데..
  * swagger라는 게 있어서 front와 backend 사이 의사 소통 비용을 많이 줄이긴 했지만 그래도 front에게 보다 편한 인터페이스가 중요한 것 같다. 서버 입장에서 데이터를 그냥 던져 주는 게 아니고 front가 적용하기 쉽게 CamelCase로 던져주는 것도 고려해야 할 사항. ^dUOb0hpge
    * sql에서 AS를 이용해서 CamelCase로 바꿀 수 있지만 번거롭다.
    * StringUtil.*toCamelCase*()를 사용하여 속성을 CamelKey 형식으로 바꿔주는 클래스 작성
      * CamelKeyMap
        * ```java
package kr.or.cbdc.infrastructure.framework.core.support.collection;

import kr.or.cbdc.infrastructure.framework.core.support.lang.StringUtil;

public class CamelKeyMap extends BaseMap {

    private static final long serialVersionUID = -7109973190696489850L;

    @Override
    public Object put(String key, Object value) {
        return super.put(StringUtil.toCamelCase(key), value);
    }

}```
      * 이렇게 클래스 작성하면 BaseMap 타입으로 결과값을 돌려주는 sql에 바로 적용 가능.
        * ```sql
<select id="selectAbiAndBytecode" resultType="kr.or.cbdc.infrastructure.framework.core.support.collection.BaseMap">
--> <select id="selectAbiAndBytecode" resultType="kr.or.cbdc.infrastructure.framework.core.support.collection.CamelKeyMap">
        SELECT tcvci.abi_info, tcvci.bytecode_info
        FROM tb_ca_vc_verification_result tcvvr
        INNER JOIN tb_ca_verification_contract_info tcvci ON tcvci.contract_id = tcvvr.contract_id
        WHERE tcvvr.template_id = #{templateId}
    </select>
```