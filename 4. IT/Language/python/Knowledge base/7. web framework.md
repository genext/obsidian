---
title: Python Web Framework - FastAPI
tags:
  - python
  - fastapi
  - web-framework
  - asgi
  - streaming
  - uvicorn
---
## FastAPI
### StreamingResponse 분석
#### ASGI (Asynchronous Server Gateway Interface)
ASGI와 연계된 webframework이 호출. 웹앱은 ASGI server 내에서 실행된다.
##### ASGI Servers
- Uvicorn
- Hypercorn
- Daphne
##### Uvicorn 설치
⚠️ **주의**: standard로 설치하지 않으면 uvloop가 설치되지 않고 eventloop로 asyncio를 사용하게 되는데 그러면 성능이 떨어진다. 확인 필요!
```shell
pip install uvicorn[standard]
```
#### 실행 순서
1. HTTP 요청 → ASGI → route handler → 내 함수 호출 → return StreamingResponse
2. ASGI server는 scope, receive, send를 만들어서 StreamingResponse의 `__call__`을 호출할 때 인자로 넘겨줌
##### ASGI 파라미터 설명
- **scope**: HTTP request/connection에 관한 정보(header, method 등)가 있음
- **receive**: 클라이언트로부터 이벤트를 받는 awaitable callable
- **send**: 클라이언트에게 이벤트를 보내는 awaitable callable
```python
# Your application code
class MyApp:
    async def some_route(self, request):
        return StreamingResponse("Hello, world!", media_type="text/html")

# ASGI Server code
class ASGIServer:
    async def handle_request(self, scope, receive, send):
        app = MyApp()
        response = await app.some_route(scope)

        # This is where the magic happens.
        await response(scope, receive, send)  # This calls StreamingResponse.__call__
```
#### Asynchronous Programming for Streaming
asynchronous programming을 사용해서 streaming HTTP responses를 보내준다.
##### 주요 함수
- **iterate_in_threadpool(content)**: 동기 iterator content를 비동기로 바꾼다
- **__call__**: 이 함수는 클래스를 [[callable]]로 바꾼다
	- In the given StreamingResponse class, the \_\_call\_\_ method is designed to be the entry point when the response starts being processed.
	- 이 클래스를 다른 함수에서는 이런 식으로 호출한다:
```python
	def some_function():
    	return StreamingResponse(answer, media_type="text/html")
```

- **anyio.create_task_group()**: 동시에 실행해야 하는 여러 작업을 실행할 때 사용
#### StreamingResponse 클래스 구현
```python
class StreamingResponse(Response):
    # body_iterator: 나중에 클라이언트에게 chunk of data를 보낼 때 쓸
    # 비동기 스트림 저장하는 변수
    body_iterator: AsyncContentStream

    def __init__(
        self,
        content: ContentStream,
        status_code: int = 200,
        headers: typing.Optional[typing.Mapping[str, str]] = None,
        media_type: typing.Optional[str] = None,
        background: typing.Optional[BackgroundTask] = None,
    ) -> None:
        if isinstance(content, typing.AsyncIterable):
            self.body_iterator = content
        else:
            self.body_iterator = iterate_in_threadpool(content)
        self.status_code = status_code
        self.media_type = self.media_type if media_type is None else media_type
        # background는 스트리밍할 동안 별도로 실행할 작업
        self.background = background
        self.init_headers(headers)

    async def listen_for_disconnect(self, receive: Receive) -> None:
        while True:
            message = await receive()
            if message["type"] == "http.disconnect":
                break

    # 인스턴스 변수 body_iterator에서 하나씩 꺼내서
    # async HTTP response를 보낸다.
    async def stream_response(self, send: Send) -> None:
        await send(
            {
                "type": "http.response.start",
                "status": self.status_code,
                "headers": self.raw_headers,
            }
        )
        async for chunk in self.body_iterator:
            if not isinstance(chunk, bytes):
                chunk = chunk.encode(self.charset)
            await send({"type": "http.response.body", "body": chunk, "more_body": True})

        await send({"type": "http.response.body", "body": b"", "more_body": False})

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        async with anyio.create_task_group() as task_group:

            async def wrap(func: "typing.Callable[[], typing.Awaitable[None]]") -> None:
                await func()
                task_group.cancel_scope.cancel()

            task_group.start_soon(wrap, partial(self.stream_response, send))
            await wrap(partial(self.listen_for_disconnect, receive))

        if self.background is not None:
            await self.background()
```
#### Response 베이스 클래스
```python
class Response:
    media_type = None
    charset = "utf-8"

    def __init__(
        self,
        content: typing.Any = None,
        status_code: int = 200,
        headers: typing.Optional[typing.Mapping[str, str]] = None,
        media_type: typing.Optional[str] = None,
        background: typing.Optional[BackgroundTask] = None,
    ) -> None:
        self.status_code = status_code
        if media_type is not None:
            self.media_type = media_type
        self.background = background
        self.body = self.render(content)
        self.init_headers(headers)

    def render(self, content: typing.Any) -> bytes:
        if content is None:
            return b""
        if isinstance(content, bytes):
            return content
        return content.encode(self.charset)

    def init_headers(
        self, headers: typing.Optional[typing.Mapping[str, str]] = None
    ) -> None:
        if headers is None:
            raw_headers: typing.List[typing.Tuple[bytes, bytes]] = []
            populate_content_length = True
            populate_content_type = True
        else:
            raw_headers = [
                (k.lower().encode("latin-1"), v.encode("latin-1"))
                for k, v in headers.items()
            ]
            keys = [h[0] for h in raw_headers]
            populate_content_length = b"content-length" not in keys
            populate_content_type = b"content-type" not in keys

        body = getattr(self, "body", None)
        if (
            body is not None
            and populate_content_length
            and not (self.status_code < 200 or self.status_code in (204, 304))
        ):
            content_length = str(len(body))
            raw_headers.append((b"content-length", content_length.encode("latin-1")))

        content_type = self.media_type
        if content_type is not None and populate_content_type:
            if content_type.startswith("text/"):
                content_type += "; charset=" + self.charset
            raw_headers.append((b"content-type", content_type.encode("latin-1")))

        self.raw_headers = raw_headers

    @property
    def headers(self) -> MutableHeaders:
        if not hasattr(self, "_headers"):
            self._headers = MutableHeaders(raw=self.raw_headers)
        return self._headers

    def set_cookie(
        self,
        key: str,
        value: str = "",
        max_age: typing.Optional[int] = None,
        expires: typing.Optional[typing.Union[datetime, str, int]] = None,
        path: str = "/",
        domain: typing.Optional[str] = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: typing.Optional[Literal["lax", "strict", "none"]] = "lax",
    ) -> None:
        cookie: "http.cookies.BaseCookie[str]" = http.cookies.SimpleCookie()
        cookie[key] = value
        if max_age is not None:
            cookie[key]["max-age"] = max_age
        if expires is not None:
            if isinstance(expires, datetime):
                cookie[key]["expires"] = format_datetime(expires, usegmt=True)
            else:
                cookie[key]["expires"] = expires
        if path is not None:
            cookie[key]["path"] = path
        if domain is not None:
            cookie[key]["domain"] = domain
        if secure:
            cookie[key]["secure"] = True
        if httponly:
            cookie[key]["httponly"] = True
        if samesite is not None:
            assert samesite.lower() in [
                "strict",
                "lax",
                "none",
            ], "samesite must be either 'strict', 'lax' or 'none'"
            cookie[key]["samesite"] = samesite
        cookie_val = cookie.output(header="").strip()
        self.raw_headers.append((b"set-cookie", cookie_val.encode("latin-1")))

    def delete_cookie(
        self,
        key: str,
        path: str = "/",
        domain: typing.Optional[str] = None,
        secure: bool = False,
        httponly: bool = False,
        samesite: typing.Optional[Literal["lax", "strict", "none"]] = "lax",
    ) -> None:
        self.set_cookie(
            key,
            max_age=0,
            expires=0,
            path=path,
            domain=domain,
            secure=secure,
            httponly=httponly,
            samesite=samesite,
        )

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        await send(
            {
                "type": "http.response.start",
                "status": self.status_code,
                "headers": self.raw_headers,
            }
        )
        await send({"type": "http.response.body", "body": self.body})

        if self.background is not None:
            await self.background()
```
### run_in_threadpool
(추가 내용 필요)
