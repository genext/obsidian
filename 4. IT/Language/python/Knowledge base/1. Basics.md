---
title: Python Basics
tags:
  - python
  - basics
  - programming
---

## 파이썬 모듈 사용
?
```python
import circle as c -> 같은 디렉토리에 있는 circle.py를 가져다 쓰겠다.
ar = c.A(r)

from circle import A as a
ar = a(r)

3rd party도 동일
```
<!--SR:!2025-11-18,9,230-->
-
## Dictionary
Dictionary는 `{key: value}` 형식으로 사용합니다.
### 특징
- Dictionary keys는 반드시 **immutable**해야 합니다 (내부적으로 hash를 사용하기 때문)
- List는 key로 사용할 수 없습니다
- Tuple은 immutable하므로 dictionary key로 사용 가능합니다
- 단, tuple이 key로 사용되려면 tuple 내부의 모든 요소도 immutable해야 합니다
### 예제

```python
# This dictionary has number keys unlike conventional string keys and values are arrays.
CONST_HTTP_RESPONSE_CODE = {
    # CD   SHORT(EN)                             LONG(KR)
     100 : ["Continue"                          ,"클라이언트로부터 일부 요청을 받았으며 나머지 정보를 계속 요청함"                    ]
    ,101 : ["Switching protocols"               ,"client가 대체 프로토콜의 사용 요청을 위해 Upgrade 헤더를 사용, 서버는 이를 받아들임"]
    ,200 : ["OK"                                ,"반환할 자료가 없습니다."                                                            ]
    ,201 : ["Created"                           ,"PUT 메소드에 의해 원격지 서버에 파일 생성됨"                                        ]
    ,202 : ["Accepted"                          ,"웹 서버가 명령 수신함"                                                              ]
    ,203 : ["Non-authoritative information"     ,"서버가 클라이언트 요청 중 일부만 전송"                                              ]
    ,204 : ["No content"                        ,"요청을 처리하였으나 전송할 데이터가 없습니다."                                      ]
    ,301 : ["Moved permanently"                 ,"요청한 데이터를 변경된 타 URL에 요청함"                                             ]
    ,302 : ["Found"                             ,"요청한 자원이 일시적으로 다른 URL 사용"                                             ]
    ,304 : ["Not modified"                      ,"컴퓨터 로컬의 캐시 정보를 이용함, 대개 gif 등은 웹 서버에 요청하지 않음"            ]
    ,400 : ["Bad request"                       ,"요청 포멧을 확인해 주세요."                                                         ]
    ,401 : ["Unauthorized"                      ,""                                                                                   ]
    ,402 : ["Payment required"                  ,"예약됨"                                                                             ]
    ,403 : ["Forbidden"                         ,""                                                                                   ]
    ,404 : ["Not found"                         ,"리소스가 존재하지 않습니다."                                                        ]
    ,405 : ["Method not allowed"                ,"요청 메소드(POST, GET)를 확인해 주세요."                                            ]
    ,407 : ["Proxy authentication required"     ,""                                                                                   ]
    ,408 : ["Request timeout"                   ,"서버에서의 처리 시간이 초과 되었습니다."                                            ]
    ,410 : ["Gone"                              ,"영구적으로 사용 금지"                                                               ]
    ,412 : ["Precondition failed"               ,"전체 조건 실패"                                                                     ]
    ,414 : ["Request-URI too long"              ,"요청 URL 길이가 긴 경우임"                                                          ]
    ,500 : ["Internal server error"             ,"서버 명령 처리 중 오류가 발생 하였습니다."                                          ]
    ,501 : ["Not implemented"                   ,"웹 서버가 처리할 수 없음"                                                           ]
    ,503 : ["Service unavailable"               ,"서비스 제공 불가"                                                                   ]
    ,504 : ["Gateway timeout"                   ,"게이트웨이 시간 초과"                                                               ]
    ,505 : ["HTTP version not supported"        ,"해당 http 버전 지원되지 않음"                                                       ]
    ,599 : ["No data from Data base"            ,"Database에 데이터 조회 결과 없음"]
}

# get the array of the number key
print(CONST_HTTP_RESPONSE_CODE[100])

# get an element of the array value.
print(CONST_HTTP_RESPONSE_CODE[100][1])

# tuple can be a key of dictionary!!! Weird!!
other_type_dict = {(0,1): 'weird!!!!!!'}
print(other_type_dict[(0,1)])
```

**Output:**
```shell
['Continue', '클라이언트로부터 일부 요청을 받았으며 나머지 정보를 계속 요청함']
클라이언트로부터 일부 요청을 받았으며 나머지 정보를 계속 요청함
weird!!!!!!
```

## Set

`{data1, data2, data3}` 형식으로 사용하며, dictionary와 유사하게 immutable합니다.

### 예제

```python
# Define a set
my_set = {"model_name", "date", "mem_IDX"}

# Add an element to the set
my_set.add("new_element")
print(my_set)

# Remove an element from the set
my_set.remove("date")
print(my_set)

# Check if an element is in the set
print("model_name" in my_set)

# Operations like union, intersection
other_set = {"model_name", "version", 1, (1,2)}
union_set = my_set.union(other_set)
print(union_set)

intersection_set = my_set.intersection(other_set)
print(intersection_set)
```

## List Slicing

### 기본 슬라이싱 `[:]`

```python
st1 = [1,2,3,4,5]
st2 = st1[2:5] # index 2 부터 4까지
```

### 시작과 끝 인덱스 생략

```python
st1 = [1,2,3,4,5]
st2 = st[0:3] # == st[:3]
st2 = st[2:]  # == st[2:5]
st2 = st[:]   # == st[0:5]
```

### Step 사용

```python
st1 = [1,2,3,4,5,6,7,8,9,10]
st2 = st[0:9:2] # 홀수만
print(st2)
[1,3,5,7,9]
```

## Generator
### 특징
- yield가 함수 정의에 있으면 그 함수는 generator.
- 공간복잡도가 상수
- Lazy evaluation을 가능케 하는 iterator의 한 종류
- map, filter도 generator 함수. 이들이 반환하는 것은 iterator 객체이자 generator.
- `next(generator)`를 하면 generator의 값을 하나씩 얻을 수 있음
- Streaming에 사용 가능
### Generator Expression
```python
# Python code to illustrate generator expression
generator = (num ** 2 for num in range(10))
for num in generator:
    print(num)
```
### Generator function
```python
def get_nums():
    ns = [0,1,2,3,4]
    for i in ns:
        yield i

# or
def get_nums():
    ns = [0,1,2,3,4]
    yield from ns

g = get_nums()
next(g) # --> 0
next(g) # --> 1
```
## Serialization/Deserialization
- 데이터 객체가 단순해서 JSON처럼 보이면 JSON serialization을 사용할 수 있습니다. 하지만 Python만의 특징이 있는 객체는 pickling/unpickling을 사용해야 합니다.
- !Security warning: Never unpickle data from untrusted sources - pickle can execute arbitrary code during deserialization
- pickling(serialization): convert python object to a byte stream
- unpickling(deserialization): retrieve python object from a binary data

### JSON vs Pickle 비교
```python
# Original data with Python-specific types
data = {
    'coordinates': (10, 20),      # tuple
    'unique_ids': {1, 2, 3},      # set
    'items': ['a', 'b', 'c']      # list
}

# JSON serialization
json_result = json.loads(json.dumps(data))
print(type(json_result['coordinates']))  # <class 'list'> ❌ (was tuple)
# json_result['unique_ids'] would cause an error since sets aren't JSON serializable

# Pickle serialization
pickle_result = pickle.loads(pickle.dumps(data))
print(type(pickle_result['coordinates']))  # <class 'tuple'> ✅ (preserved)
print(type(pickle_result['unique_ids']))   # <class 'set'> ✅ (preserved)
```

## Pack/Unpack
### *args
- **함수 정의에서**: "임의의 개수의 positional argument를 받아서 tuple로 pack"
- **함수 호출에서**: "tuple/list를 unpack해서 각 요소를 별도의 argument로 전달"
### **kwargs
- `*args`와 동일한 원리로 키워드 인자에 적용

## Decorator

### 인자가 있는 함수를 위한 Decorator
```python
def adder2(n1, n2):
  return n1+n2

def adder_deco(func):
  def ad(*args):
    print(*args, sep=" + ", end = ' ')
    print("= {0}".format(func(*args)))
# {0} is a placeholder for the first argument passed to .format()
# 하지만 위 format은 오래된 것. 새 방식은
print(f"={func(*args)}")

  return ad

# 직접 지정
adder2 = adder_deco(adder2)
# 데코레이터 이용
@adder_deco
def adder2(n1, n2):
    return n1 + n2

adder2(3,4)  --> 3 + 4 = 7
```

#python 