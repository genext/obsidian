---
title: Python Interview Questions
tags:
  - python
  - interview
  - programming
source: https://www.geeksforgeeks.org/python-interview-questions/?ref=lbp
---
## Immutable Data Type
- String, tuple: we can't change values of immutable data types at runtime
- Key of dictionary or elements of set must be immutable because they are hashed for the storing structure.
## Function Arguments Are Passed by Reference
- **Immutable objects** such as integers, floats, strings, and tuples cannot be altered. If you try to change an immutable object inside a function, you actually create a new object and change the function's local reference to point to this new object. The original object outside the function remains unchanged.
- **Mutable objects** like lists, dictionaries, and sets can be modified in place. If you modify a mutable object inside a function, the changes will be reflected in the original object outside the function
## The Difference Between Set and Dictionary

| Set                             | Dictionary   |
| ------------------------------- | ------------ |
| unordered                       | ordered      |
| iterable, mutable, no duplicate | store values |
## Lambda Function
An anonymous function. This function can have any number of parameters but, can have just one statement.
```python
a = lambda x, y : x*y
print(a(7, 19))
```
## \*args, \*\*kwargs
### In Function Definitions and Calling Functions
#### \*args
Allows you to take in more arguments than the number of formal arguments that you previously defined.
```python
def myFun(*args):
    for arg in args:
        print(arg)

# direct passing arguments
myFun('Hello', 'Welcome', 'to', 'practice')

args1 = ('Hello', 'Welcome', 'to', 'GeeksforGeeks')
args2 = ['Hello', 'Welcome', 'to', 'my Exercise']

# unpacking
myFun(*args1)
myFun(*args2)
```
#### \*\*kwargs
The dictionary equivalent of \*args
```python
def myFun(**kwargs):
    for key, value in kwargs.items():
        print("%s == %s" % (key, value))


# direct passing
myFun(first='Geeks', mid='for', last='Geeks')

# unpacking
kwargs = {"first": "Geeks", "mid": "for", "last": "Geeks"}
myFun(**kwargs)
```
### Set Values of Created Object
#### Using \*args
```python
# defining car class
class car():
    # args receives unlimited no. of arguments as an array
    def __init__(self, *args):
        # access args index like array does
        self.speed = args[0]
        self.color = args[1]


# creating objects of car class
audi = car(200, 'red')
bmw = car(250, 'black')
mb = car(190, 'white')

# printing the color and speed of the cars
print(audi.color)
print(bmw.speed)
```
#### Using \*\*kwargs
```python
# defining car class
class car():
    # args receives unlimited no. of arguments as an array
    def __init__(self, **kwargs):
        # access args index like array does
        self.speed = kwargs['s']
        self.color = kwargs['c']


# creating objects of car class
audi = car(s=200, c='red')
bmw = car(s=250, c='black')
mb = car(s=190, c='white')

# printing the color and speed of cars
print(audi.color)
print(bmw.speed)
```
## Docstring
### Declare
Below the class, method, or function declaration.
```python
def function():
    '''
    triple single quotes
    '''
    ...

class Car():
    """
    triple double quotes
    """
    ...
```
### Accessing Docstring
The docstrings can be accessed using the \_\_doc\_\_ method of the object or using the help function.
```python
def my_function():
    """This is a docstring for my_function."""
    pass

print(my_function.__doc__)

class MyClass:
    """This is a docstring for MyClass."""

    def my_method(self):
        """This is a docstring for my_method."""
        pass

print(MyClass.__doc__)
print(MyClass.my_method.__doc__)
```

## Comprehension
A concise, elegant way to define and create lists or dictionaries (from a list or any iterable)
### List Comprehension
```python
r1 = [1,2,3,4,5]
r2 = [x * 2 for x in r1] # --> [2,4,6,8,10]

r2 = [x * 2 for x in r1 if x % 2] # --> [2,6,9]
```
### Dictionary Comprehension
A dictionary is not iterable but items() method returns iterator.
```python
d1 = dict(a = 1, b = 2, c = 3)
d2 = {k: v * 2 for k, v in d1.items()} # --> {'a': 2, 'b': 4, 'c': 6}

d2 = {k: v for k, v in d1.items() if v % 2} # --> {'a': 1, 'c': 3}

keys = ['a','b','c','d','e']
values = [1,2,3,4,5]

# this line shows dict comprehension here
d = { k:v for (k,v) in zip(keys, values)}

# We can use below too
# d = dict(zip(keys, values))

print (d)
```

## Shallow/Deep Copy
```python
# Python program to illustrate the difference between shallow and deep copy
import copy

class Car:
    def __init__(self, name, colors):
        self.name = name
        self.colors = colors

# Create a Honda car object
honda_colors = ["Red", "Blue"]
honda = Car("Honda", honda_colors)

# Deepcopy of Honda
deepcopy_honda = copy.deepcopy(honda)
deepcopy_honda.colors.append("Green")
print("Deepcopy:", deepcopy_honda.colors)
print("Original:", honda.colors)

# Shallow Copy of Honda
copy_honda = copy.copy(honda)
copy_honda.colors.append("Green")
print("Shallow Copy:", copy_honda.colors)
print("Original:", honda.colors)
```
Output:
```shell
Deepcopy: ['Red', 'Blue', 'Green']
Original: ['Red', 'Blue']
Shallow Copy: ['Red', 'Blue', 'Green']
Original: ['Red', 'Blue', 'Green']
```
## Decorator
The **outer function** is called the decorator, which takes the original function as an argument and returns a modified version of it.
### Syntax
#### Without Parameter
```python
@gfg_decorator
def hello_decorator():
    print("Gfg")

'''Above code is equivalent to -

def hello_decorator():
    print("Gfg")

hello_decorator = gfg_decorator(hello_decorator)'''
```
Example:
```python
def make_pretty(func):
    # define the inner function
    def inner():
        # add some additional behavior to decorated function
        print("I got decorated")

        # call original function
        func()
    # return the inner function
    return inner

# define ordinary function
def ordinary():
    print("I am ordinary")

# decorate the ordinary function
decorated_func = make_pretty(ordinary)

# call the decorated function
decorated_func()
```
Using "@" syntax:
```python
def make_pretty(func):
    # define the inner function
    def inner():
        # add some additional behavior to decorated function
        print("I got decorated")
        # call original function
        func()
    # return the inner function
    return inner

# define ordinary function and decorate it
@make_pretty
def ordinary():
    print("I am ordinary")

# call the decorated function
ordinary()
```
#### With Parameter
```python
# importing libraries
import time
import math

# decorator to calculate duration
# taken by any function.
def calculate_time(func):

	# added arguments inside the inner1,
	# if function takes any arguments,
	# can be added like this.
	def inner1(*args, **kwargs):

		# storing time before function execution
		begin = time.time()

		func(*args, **kwargs)

		# storing time after function execution
		end = time.time()
		print("Total time taken in : ", func.__name__, end - begin)

	return inner1

# this can be added to any function present,
# in this case to calculate a factorial
@calculate_time
def factorial(num):

	# sleep 2 seconds because it takes very less time
	# so that you can see the actual difference
	time.sleep(2)
	print(math.factorial(num))

# calling the function.
factorial(10)
```
### Chaining
```python
def star(func):
    def inner(*args, **kwargs):
        print("*" * 15)
        func(*args, **kwargs)
        print("*" * 15)
    return inner


def percent(func):
    def inner(*args, **kwargs):
        print("%" * 15)
        func(*args, **kwargs)
        print("%" * 15)
    return inner

@star
@percent
def printer(msg):
    print(msg)

# star, percent decorator 호출 풀이
def printer(msg):
    print(msg)
printer = star(percent(printer))

printer("Hello")
```
Output:
```shell
***************
%%%%%%%%%%%%%%%
Hello
%%%%%%%%%%%%%%%
***************
```
ref: [[2. Annotations and Decorators]]
## How to Debug
```shell
python -m pdb my_program.py
```
## zip
You can efficiently iterate over multiple iterables in parallel and perform operations on corresponding elements from each iterable.
```python
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)  # --> returns zip object
list(zipped)  # Output: [(1, 4), (2, 5), (3, 6)]

# Unzipping can be achieved by using zip(*zippedList).
x2, y2 = zip(*zip(x, y))
x == list(x2) and y == list(y2)  # Output: True
```
## Monkey Patching
A technique that allows developers to modify or extend code at runtime without altering the original source code.
## Access Specifier
Python uses the '_' symbol to determine the access control for a specific data member or a member function of a class.
### Public (without '\_')
```python
class Geek:

     # constructor
     def __init__(self, name, age):

           # public data members
           self.geekName = name
           self.geekAge = age
```
### Protected ('\_')
```python
# super class
class Student:

     # protected data members
     _name = None
     _roll = None
     _branch = None

     # constructor
     def __init__(self, name, roll, branch):
          self._name = name
          self._roll = roll
          self._branch = branch

     # protected member function
     def _displayRollAndBranch(self):

          # accessing protected data members
          print("Roll: ", self._roll)
          print("Branch: ", self._branch)

# derived class
class Geek(Student):

       # constructor
       def __init__(self, name, roll, branch):
                Student.__init__(self, name, roll, branch)

       # public member function
       def displayDetails(self):

                 # accessing protected data members of super class
                print("Name: ", self._name)

                 # accessing protected member functions of super class
                self._displayRollAndBranch()

# creating objects of the derived class
obj = Geek("R2J", 1706256, "Information Technology")

# calling public member functions of the class
obj.displayDetails()
```
### Private ('\_\_')
```python
# program to illustrate private access modifier in a class

class Geek:

	# private members
	__name = None
	__roll = None
	__branch = None

	# constructor
	def __init__(self, name, roll, branch):
		self.__name = name
		self.__roll = roll
		self.__branch = branch

	# private member function
	def __displayDetails(self):

		# accessing private data members
		print("Name: ", self.__name)
		print("Roll: ", self.__roll)
		print("Branch: ", self.__branch)

	# public member function
	def accessPrivateFunction(self):

		# accessing private member function
		self.__displayDetails()

# creating object
obj = Geek("R2J", 1706256, "Information Technology")

# calling public member function of the class
obj.accessPrivateFunction()
```
## Type Check
### Mypy: Static Type Checker
```shell
pip install mypy
```
### Function Annotation
Format:
```python
def greet(name: str) -> str:
    #          ==^^    ==^^
    #     parameter   return
    #    annotation  annotation
    return f"Hello, {name}!"
```
## Exception Groups
- You want to collect multiple errors instead of stopping at the first one
- Different types of errors need different handling strategies
- You're dealing with operations that can fail independently but you want to process them all
### except*
#### Basic Example
```python
try:
    raise ExceptionGroup('Example ExceptionGroup', (
        TypeError('Example TypeError'),
        ValueError('Example ValueError'),
        KeyError('Example KeyError'),
        AttributeError('Example AttributeError')
    ))
except* TypeError:
    ...
except* ValueError as e:
    ...
except* (KeyError, AttributeError) as e:
    ...
```
#### Real World Examples
##### Example 1: Using asyncio.gather()
```python
# Example 1: Using asyncio.gather() which can raise ExceptionGroup
import asyncio

async def fetch_data(url_id):
    """Simulate fetching data that might fail"""
    await asyncio.sleep(0.1)  # Simulate network delay

    if url_id == 1:
        raise ValueError(f"Invalid data format from URL {url_id}")
    elif url_id == 3:
        raise ConnectionError(f"Failed to connect to URL {url_id}")
    elif url_id == 4:
        raise TimeoutError(f"Timeout for URL {url_id}")
    else:
        return f"Data from URL {url_id}"

async def main():
    # This will naturally create an ExceptionGroup when multiple tasks fail
    tasks = [fetch_data(i) for i in range(1, 6)]

    try:
        results = await asyncio.gather(*tasks, return_exceptions=False)
        print("All succeeded:", results)

    except* ValueError as eg:
        print(f"Data format errors ({len(eg.exceptions)}):")
        for exc in eg.exceptions:
            print(f"  - {exc}")

    except* ConnectionError as eg:
        print(f"Connection errors ({len(eg.exceptions)}):")
        for exc in eg.exceptions:
            print(f"  - {exc}")

    except* TimeoutError as eg:
        print(f"Timeout errors ({len(eg.exceptions)}):")
        for exc in eg.exceptions:
            print(f"  - {exc}")

# Run the async example
# asyncio.run(main())  # Uncomment to run
```
##### Example 2: Batch Processing with Error Collection
```python
def validate_user_data(users):
    """Validate multiple users and collect all validation errors"""
    errors = []

    for i, user in enumerate(users):
        try:
            # Simulate various validation checks
            if not user.get('email'):
                raise ValueError(f"User {i}: Email is required")
            if '@' not in user.get('email', ''):
                raise ValueError(f"User {i}: Invalid email format")
            if user.get('age', 0) < 0:
                raise ValueError(f"User {i}: Age cannot be negative")
            if not user.get('name'):
                raise KeyError(f"User {i}: Name field is missing")

        except Exception as e:
            errors.append(e)

    if errors:
        raise ExceptionGroup("User validation failed", errors)

    return "All users valid"

# Test data with various issues
test_users = [
    {'name': 'Alice', 'email': 'alice@example.com', 'age': 25},  # Valid
    {'name': 'Bob', 'email': 'invalid-email', 'age': 30},       # Invalid email
    {'email': 'charlie@example.com', 'age': -5},                # Missing name, negative age
    {'name': 'David', 'age': 40},                               # Missing email
]

try:
    result = validate_user_data(test_users)
    print("Validation result:", result)

except* ValueError as eg:
    print(f"Validation errors ({len(eg.exceptions)}):")
    for exc in eg.exceptions:
        print(f"  - {exc}")

except* KeyError as eg:
    print(f"Missing field errors ({len(eg.exceptions)}):")
    for exc in eg.exceptions:
        print(f"  - {exc}")
```
##### Example 3: File Processing with Multiple Potential Failures
```python
import os
from pathlib import Path

def process_files(file_paths):
    """Process multiple files and collect any errors"""
    errors = []
    results = []

    for file_path in file_paths:
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File not found: {file_path}")

            with open(file_path, 'r') as f:
                content = f.read()
                if len(content) == 0:
                    raise ValueError(f"Empty file: {file_path}")
                if 'ERROR' in content.upper():
                    raise RuntimeError(f"Error content found in: {file_path}")

            results.append(f"Processed {file_path}: {len(content)} chars")

        except Exception as e:
            errors.append(e)

    if errors:
        raise ExceptionGroup("File processing errors", errors)

    return results

# Test with some files (most won't exist, demonstrating real-world scenario)
test_files = [
    'config.txt',      # Probably doesn't exist
    'data.csv',        # Probably doesn't exist
    'error_log.txt',   # Probably doesn't exist
    'README.md'        # Might exist
]

try:
    results = process_files(test_files)
    print("File processing results:")
    for result in results:
        print(f"  {result}")

except* FileNotFoundError as eg:
    print(f"Missing files ({len(eg.exceptions)}):")
    for exc in eg.exceptions:
        print(f"  - {exc}")

except* ValueError as eg:
    print(f"Content validation errors ({len(eg.exceptions)}):")
    for exc in eg.exceptions:
        print(f"  - {exc}")

except* RuntimeError as eg:
    print(f"Runtime errors ({len(eg.exceptions)}):")
    for exc in eg.exceptions:
        print(f"  - {exc}")

print("\nThese examples show ExceptionGroup in realistic scenarios where:")
print("1. Multiple async operations fail simultaneously")
print("2. Batch validation finds multiple errors")
print("3. File processing encounters various issues")
print("4. You want to handle different error types appropriately")
```
