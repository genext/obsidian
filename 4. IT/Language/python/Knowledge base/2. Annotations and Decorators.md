---
title: Python Annotations and Decorators
tags:
  - python
  - decorators
  - annotations
  - dataclass
  - classmethod
  - staticmethod
  - property
  - contextmanager
---

# Annotations and Decorators

## @dataclass
- [ ] 이 데코레이터는 자신이 꾸미는 클래스에게 저장을 위한 특수 메소드를 자동 생성해 줌. equal, hash, toString → java의 #record 와 동일
- In production code, dataclasses are especially valuable for configuration objects, DTOs (Data Transfer Objects), result containers
### Code Sample
```python
from dataclasses import dataclass


@dataclass
class Person:
    name: str
    age: int
    email: str


# Without @dataclass, you'd need to write this manually:
class PersonManual:
    def __init__(self, name: str, age: int, email: str):
        self.name = name
        self.age = age
        self.email = email

    def __repr__(self):
        return f"PersonManual(name='{self.name}', age={self.age}, email='{self.email}')"

    def __eq__(self, other):
        if not isinstance(other, PersonManual):
            return False
        return (self.name, self.age, self.email) == (other.name, other.age, other.email)

    def __hash__(self):
        return hash((self.name, self.age, self.email))

# Makes instances immutable -> Can be used as dictionary keys
@dataclass(frozen=True)
class Point:
  x: float
  y: float


# Adds comparison methods (<, >, etc.)
@dataclass(order=True)
class Score:
  value: int
```
<!--SR:!2025-10-11,3,250-->
## @classmethod
The method receives the class itself as the first argument (conventionally named cls)
**Key Characteristics:**
- Can access and modify class attributes
- Can be called on both the class and instances
- Often used for **alternative** constructors, factory methods that return class instance
### Code Examples
```python
class Person:
    species = "Homo sapiens"  # class attribute

    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_string(cls, person_str):
        # Alternative constructor - can create new instances
        name, age = person_str.split('-')
        return cls(name, int(age))  # cls refers to the Person class

# Usage examples:
# @classmethod usage
person1 = Person.from_string("Alice-25")  # Creates new Person instance
print(Person.get_species())  # "Homo sapiens"


# for class-level data operation
class DatabaseConnection:
    _instances = []  # Class-level data

    def __init__(self, host, port):
        self.host = host
        self.port = port
        DatabaseConnection._instances.append(self)

    @classmethod
    def get_active_connections(cls):
        return len(cls._instances)  # Operates on class data

    @classmethod
    def close_all_connections(cls):
        for instance in cls._instances:
            instance.close()
        cls._instances.clear()


# Usage:
db1 = DatabaseConnection("localhost", 5432)
db2 = DatabaseConnection("remote", 5432)


print(DatabaseConnection.get_active_connections())  # 2
DatabaseConnection.close_all_connections()          # Affects all instances

# JSON module pattern
class Config:
    @classmethod
    def from_file(cls, filename):
        with open(filename) as f:
            data = json.load(f)
        return cls(**data)
```
<!--SR:!2025-10-13,3,250-->
## @staticmethod
**Utility Pattern** - Similar to static methods in Java
**Key Characteristics:**
- The method receives no special first argument
- Cannot access class or instance attributes directly
- Behaves like a regular function but belongs to the class namespace
- Used for utility functions related to the class
### Code Example
```python
class Calculator:
    @staticmethod
    def add(x, y):
        # self나 cls에 접근할 수 없고, 클래스 상태도 사용하지 않습니다.
        return x + y

# 클래스 이름을 통해 직접 호출합니다.
result = Calculator.add(5, 3)
print(result)  # 출력: 8

# 인스턴스를 통해 호출할 수도 있습니다.
calc_instance = Calculator()
result_instance = calc_instance.add(10, 2)
print(result_instance)  # 출력: 12
```
<!--SR:!2025-10-11,3,250-->
## @functools.wraps
**To preserve original function's metadata (name, doc, module) when you create decorator**
`@wraps` is specifically used *inside* decorator definitions to make your decorators behave more transparently by preserving the original function's `__name__`, `__doc__`, `__module__`, and other attributes. It's a best practice when writing decorators to make debugging and introspection easier.
### Code Example
```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # This preserves func's metadata
    def wrapper(*args, **kwargs):
        print("Before function")
        result = func(*args, **kwargs)
        print("After function")
        return result
    return wrapper

@my_decorator
def greet(name):
    """Says hello to someone"""
    return f"Hello, {name}!"

print(greet.__name__)    # Now prints "greet"
print(greet.__doc__)     # Now prints "Says hello to someone"
```
<!--SR:!2025-10-11,3,250-->
## @contextmanager
Decorator 사용시, 함수 기본구조는:
```python
@contextmanager
def func_name():
  try:
    yield something
  finally:
    cleanup
```
### Timer Example
```python
from contextlib import contextmanager
import time

@contextmanager
def timer():
  start = time.time()
  print("Timer started")
  try:
    yield start  # This value is returned to the 'as' variable
  finally:
    end = time.time()
    print(f"Timer finished: {end - start:.2f} seconds")

# Usage
with timer() as start_time:
  time.sleep(1)
  print(f"Started at: {start_time}")
```
### Temporary Directory Example
```python
import os
import tempfile
import shutil
from contextlib import contextmanager

@contextmanager
def temporary_directory():
  temp_dir = tempfile.mkdtemp()
  try:
    yield temp_dir
  finally:
    # Always clean up, even if an exception occurred
    shutil.rmtree(temp_dir)

# Usage
with temporary_directory() as temp_dir:
  # Create some files in temp_dir
  file_path = os.path.join(temp_dir, "test.txt")
  with open(file_path, "w") as f:
    f.write("Hello, world!")
    # Do work with temporary files
    print(f"Working in: {temp_dir}")

# temp_dir is automatically cleaned up here
```
### Database Connection Example
```python
# Database connection
from contextlib import contextmanager

@contextmanager
def database_connection(connection_string):
  print("Opening database connection")
  # Simulate opening a connection
  connection = f"Connected to {connection_string}"

  try:
    yield connection
  finally:
    print("Closing database connection")
    # Cleanup code here - close the actual connection
    connection = None

# Usage - exactly the same as before
with database_connection("postgresql://localhost") as conn:
  print(f"Using {conn}")
  # Connection automatically closed when exiting the block
```
<!--SR:!2025-10-11,3,250-->
## @property
`@property` creates a descriptor object. You must define the getter first, then use `@name.setter`
### Code Example
```python
class Circle:
  _radius: float  # This is ONLY a type hint, NOT creating a variable!
  def __init__(self, radius):
    self.radius = radius    # Uses the setter! creating instance variable

  @property
  def radius(self):
    return self._radius

  @radius.setter
  def radius(self, value):
    if not isinstance(value, (int, float)):
      raise TypeError("Radius must be a number")
    if value <= 0:
      raise ValueError("Radius must be positive")
    self._radius = value

  @property
  def area(self):
    return 3.14159 * self._radius ** 2

# Usage
c = Circle(5)
print(c.radius)    # 5 (calls getter)
c.radius = 10      # Calls setter
print(c.area)      # 314.159 (computed)
# c.area = 100     # Error: can't set (no setter defined)
```
<!--SR:!2025-10-11,3,250-->


#python 